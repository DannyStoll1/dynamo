#![allow(warnings)]

/* automatically generated by rust-bindgen 0.66.1 */

pub const _MATH_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 36;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_TYPES_STRUCT_SCHED_PARAM: u32 = 1;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const __jmp_buf_tag_defined: u32 = 1;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __GMP_HAVE_HOST_CPU_FAMILY_power: u32 = 0;
pub const __GMP_HAVE_HOST_CPU_FAMILY_powerpc: u32 = 0;
pub const GMP_LIMB_BITS: u32 = 64;
pub const GMP_NAIL_BITS: u32 = 0;
pub const GMP_NUMB_BITS: u32 = 64;
pub const __GNU_MP__: u32 = 6;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const __GMP_LIBGMP_DLL: u32 = 0;
pub const __GMP_MP_SIZE_T_INT: u32 = 0;
pub const _GMP_H_HAVE_FILE: u32 = 1;
pub const _GMP_H_HAVE_VA_LIST: u32 = 1;
pub const __GMP_INLINE_PROTOTYPES: u32 = 1;
pub const __GMP_CC: &[u8; 3] = b"cc\0";
pub const __GMP_CFLAGS : & [u8 ; 115] = b"-fstack-clash-protection -D_FORTIFY_SOURCE=2 -mtune=generic -O2 -pipe   -g -ffile-prefix-map=/builddir/gmp-6.3.0=.\0" ;
pub const __GNU_MP_VERSION: u32 = 6;
pub const __GNU_MP_VERSION_MINOR: u32 = 3;
pub const __GNU_MP_VERSION_PATCHLEVEL: u32 = 0;
pub const __GNU_MP_RELEASE: u32 = 60300;
pub const MPS_CHEBYSHEV_POLY_TYPE_NAME: &[u8; 19] = b"mps_chebyshev_poly\0";
pub const MPS_MONOMIAL_MATRIX_POLY_HESSENBERG: u32 = 1;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &[u8; 48] = b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &[u8; 5] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &[u8; 5] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &[u8; 5] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const MPS_DEBUG_INFO: u32 = 1;
pub const MPS_DEBUG_CLUSTER: u32 = 2;
pub const MPS_DEBUG_APPROXIMATIONS: u32 = 4;
pub const MPS_DEBUG_IMPROVEMENT: u32 = 8;
pub const MPS_DEBUG_TIMINGS: u32 = 16;
pub const MPS_DEBUG_FUNCTION_CALLS: u32 = 32;
pub const MPS_DEBUG_IO: u32 = 64;
pub const MPS_DEBUG_MEMORY: u32 = 128;
pub const MPS_DEBUG_PACKETS: u32 = 256;
pub const MPS_DEBUG_REGENERATION: u32 = 512;
pub const MPS_DEBUG_TRACE: u32 = 65535;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _ALLOCA_H: u32 = 1;
pub const MPS_MAJOR_VERSION: u32 = 3;
pub const MPS_MINOR_VERSION: u32 = 2;
pub const MPS_PATCH_VERSION: u32 = 1;
pub type mps_string = *const ::std::os::raw::c_char;
pub const mps_boolean_false_: mps_boolean = 0;
pub const mps_boolean_true_: mps_boolean = 1;
pub type mps_boolean = ::std::os::raw::c_uint;
pub type mps_debug_level = ::std::os::raw::c_int;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t
{
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t()
{
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub const FP_NAN: _bindgen_ty_1 = 0;
pub const FP_INFINITE: _bindgen_ty_1 = 1;
pub const FP_ZERO: _bindgen_ty_1 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_1 = 3;
pub const FP_NORMAL: _bindgen_ty_1 = 4;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec
{
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec()
{
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param
{
    pub sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param()
{
    const UNINIT: ::std::mem::MaybeUninit<sched_param> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t
{
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t()
{
    const UNINIT: ::std::mem::MaybeUninit<cpu_set_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type clock_t = __clock_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm
{
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm()
{
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec
{
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec()
{
    const UNINIT: ::std::mem::MaybeUninit<itimerspec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct
{
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct()
{
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __atomic_wide_counter
{
    pub __value64: ::std::os::raw::c_ulonglong,
    pub __value32: __atomic_wide_counter__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __atomic_wide_counter__bindgen_ty_1
{
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___atomic_wide_counter__bindgen_ty_1()
{
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__atomic_wide_counter__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___atomic_wide_counter()
{
    const UNINIT: ::std::mem::MaybeUninit<__atomic_wide_counter> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Size of: ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        ::std::mem::align_of::<__atomic_wide_counter>(),
        8usize,
        concat!("Alignment of ", stringify!(__atomic_wide_counter))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__atomic_wide_counter),
            "::",
            stringify!(__value32)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list
{
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list()
{
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist
{
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist()
{
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s
{
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s()
{
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t
{
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t()
{
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s
{
    pub __wseq: __atomic_wide_counter,
    pub __g1_start: __atomic_wide_counter,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[test]
fn bindgen_test_layout___pthread_cond_s()
{
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag
{
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag()
{
    const UNINIT: ::std::mem::MaybeUninit<__once_flag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t
{
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t()
{
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t
{
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t()
{
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t
{
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t()
{
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t
{
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t()
{
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t
{
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t()
{
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t
{
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t()
{
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t
{
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t()
{
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t
{
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t()
{
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t
{
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t()
{
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type __jmp_buf = [::std::os::raw::c_long; 8usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t
{
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t()
{
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag
{
    pub __jmpbuf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __saved_mask: __sigset_t,
}
#[test]
fn bindgen_test_layout___jmp_buf_tag()
{
    const UNINIT: ::std::mem::MaybeUninit<__jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__jmp_buf_tag>(),
        200usize,
        concat!("Size of: ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__jmpbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__jmpbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__saved_mask) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__jmp_buf_tag),
            "::",
            stringify!(__saved_mask)
        )
    );
}
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_2 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_3 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_3 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_3 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_3 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_3 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_3 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_3 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_3 = 0;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_4 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_4 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_4 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_4 = 1;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_5 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_5 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_5 = 2;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_6 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_6 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_6 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_6 = 0;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_7 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_7 = 1;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_8 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_8 = 1;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_9 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_9 = 1;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer
{
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer()
{
    const UNINIT: ::std::mem::MaybeUninit<_pthread_cleanup_buffer> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__canceltype) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_10 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_10 = 1;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_11 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_11 = 1;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void) -> !;
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cancel_jmp_buf_tag
{
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___cancel_jmp_buf_tag()
{
    const UNINIT: ::std::mem::MaybeUninit<__cancel_jmp_buf_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__cancel_jmp_buf_tag>(),
        72usize,
        concat!("Size of: ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__cancel_jmp_buf_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__cancel_jmp_buf_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mask_was_saved) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__cancel_jmp_buf_tag),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_unwind_buf_t
{
    pub __cancel_jmp_buf: [__cancel_jmp_buf_tag; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t()
{
    const UNINIT: ::std::mem::MaybeUninit<__pthread_unwind_buf_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame
{
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame()
{
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cleanup_frame> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__do_it) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cancel_type) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t) -> !;
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @brief A thread safe version of mps_boolean.\n\n Must be accessed using the macro MPS_LOCK (x) and\n MPS_UNLOCK (x)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mps_boolean_mt
{
    pub value: mps_boolean,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_mps_boolean_mt()
{
    const UNINIT: ::std::mem::MaybeUninit<mps_boolean_mt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mps_boolean_mt>(),
        48usize,
        concat!("Size of: ", stringify!(mps_boolean_mt))
    );
    assert_eq!(
        ::std::mem::align_of::<mps_boolean_mt>(),
        8usize,
        concat!("Alignment of ", stringify!(mps_boolean_mt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_boolean_mt),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_boolean_mt),
            "::",
            stringify!(mutex)
        )
    );
}
#[doc = " @brief A thread safe version of mps_boolean.\n\n Must be accessed using the macro MPS_LOCK (x) and\n MPS_UNLOCK (x)."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mps_long_int_mt
{
    pub value: ::std::os::raw::c_long,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_mps_long_int_mt()
{
    const UNINIT: ::std::mem::MaybeUninit<mps_long_int_mt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mps_long_int_mt>(),
        48usize,
        concat!("Size of: ", stringify!(mps_long_int_mt))
    );
    assert_eq!(
        ::std::mem::align_of::<mps_long_int_mt>(),
        8usize,
        concat!("Alignment of ", stringify!(mps_long_int_mt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_long_int_mt),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_long_int_mt),
            "::",
            stringify!(mutex)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_context
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_root
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_cluster
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_cluster_item
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_clusterization
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_secular_equation
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_secular_iteration_data
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_monomial_poly
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_monomial_matrix_poly
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_input_buffer
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_approximation
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_opt
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_input_option
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_command_line_option
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_command_line_option_configuration
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_list_element
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_list
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_input_configuration
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_output_configuration
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_thread_job
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_thread_job_queue
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_thread_worker_data
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_thread
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_thread_pool
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_thread_pool_queue
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_thread_pool_queue_item
{
    _unused: [u8; 0],
}
pub const mps_phase_no_phase: mps_phase = 0;
pub const mps_phase_float_phase: mps_phase = 1;
pub const mps_phase_dpe_phase: mps_phase = 2;
pub const mps_phase_mp_phase: mps_phase = 3;
#[doc = " @brief Type representing the computation phase\n of the algorithm we are in\n now. It can assume the values:\n - <code>no_phase</code>;\n - <code>float_phase</code>;\n - <code>dpe_phase</code>;\n - <code>mp_phase</code>;"]
pub type mps_phase = i32;
extern "C" {
    pub static mps_phase_string: [mps_string; 4usize];
}
pub const mps_operation_MPS_OPERATION_CLUSTER_ANALYSIS: mps_operation = 0;
pub const mps_operation_MPS_OPERATION_ABERTH_FP_ITERATIONS: mps_operation = 1;
pub const mps_operation_MPS_OPERATION_ABERTH_DPE_ITERATIONS: mps_operation = 2;
pub const mps_operation_MPS_OPERATION_ABERTH_MP_ITERATIONS: mps_operation = 3;
pub const mps_operation_MPS_OPERATION_REGENERATION: mps_operation = 4;
pub const mps_operation_MPS_OPERATION_STARTING_POINTS_FP: mps_operation = 5;
pub const mps_operation_MPS_OPERATION_STARTING_POINTS_DPE: mps_operation = 6;
pub const mps_operation_MPS_OPERATION_STARTING_POINTS_MP: mps_operation = 7;
pub const mps_operation_MPS_OPERATION_SHIFT: mps_operation = 8;
pub const mps_operation_MPS_OPERATION_REFINEMENT: mps_operation = 9;
#[doc = " @brief Used to label different operation inside the various\n algorithms."]
pub type mps_operation = i32;
extern "C" {
    pub static mps_operation_string: [mps_string; 10usize];
}
pub const mps_root_status_MPS_ROOT_STATUS_NEW_CLUSTERED: mps_root_status = 0;
pub const mps_root_status_MPS_ROOT_STATUS_CLUSTERED: mps_root_status = 1;
pub const mps_root_status_MPS_ROOT_STATUS_ISOLATED: mps_root_status = 2;
pub const mps_root_status_MPS_ROOT_STATUS_APPROXIMATED: mps_root_status = 3;
pub const mps_root_status_MPS_ROOT_STATUS_APPROXIMATED_IN_CLUSTER: mps_root_status = 4;
pub const mps_root_status_MPS_ROOT_STATUS_NOT_FLOAT: mps_root_status = 5;
pub const mps_root_status_MPS_ROOT_STATUS_NOT_DPE: mps_root_status = 6;
pub const mps_root_status_MPS_ROOT_STATUS_MULTIPLE: mps_root_status = 7;
#[doc = " @brief Status of approximation of the root."]
pub type mps_root_status = i32;
extern "C" {
    pub static mps_table_of_approximated_roots: [mps_boolean; 8usize];
}
extern "C" {
    pub static mps_table_of_computed_roots: [mps_boolean; 8usize];
}
extern "C" {
    pub static mps_table_of_improvable_roots: [mps_boolean; 8usize];
}
extern "C" {
    pub static mps_root_status_string: [mps_string; 8usize];
}
pub const mps_root_attrs_MPS_ROOT_ATTRS_NONE: mps_root_attrs = 0;
pub const mps_root_attrs_MPS_ROOT_ATTRS_REAL: mps_root_attrs = 1;
pub const mps_root_attrs_MPS_ROOT_ATTRS_NOT_REAL: mps_root_attrs = 2;
pub const mps_root_attrs_MPS_ROOT_ATTRS_IMAG: mps_root_attrs = 3;
pub const mps_root_attrs_MPS_ROOT_ATTRS_NOT_IMAG: mps_root_attrs = 4;
pub const mps_root_attrs_MPS_ROOT_ATTRS_NOT_REAL_AND_IMAG: mps_root_attrs = 5;
#[doc = " @brief Attributes that can be attached to a root and\n are mostly aimed to detect reality or not."]
pub type mps_root_attrs = i32;
extern "C" {
    pub static mps_root_attrs_string: [mps_string; 6usize];
}
pub const mps_root_inclusion_MPS_ROOT_INCLUSION_UNKNOWN: mps_root_inclusion = 0;
pub const mps_root_inclusion_MPS_ROOT_INCLUSION_IN: mps_root_inclusion = 1;
pub const mps_root_inclusion_MPS_ROOT_INCLUSION_OUT: mps_root_inclusion = 2;
#[doc = " @brief Status of inclusion of the root in the target\n set."]
pub type mps_root_inclusion = i32;
extern "C" {
    pub static mps_root_inclusion_string: [mps_string; 3usize];
}
#[doc = " @brief Standard MPsolve approach"]
pub const mps_algorithm_MPS_ALGORITHM_STANDARD_MPSOLVE: mps_algorithm = 0;
#[doc = " @brief Gemignani's approach applied to secular equations."]
pub const mps_algorithm_MPS_ALGORITHM_SECULAR_GA: mps_algorithm = 1;
#[doc = " @brief Algorithm used to find the solution of the polynomial,\n or of the secular equation."]
pub type mps_algorithm = i32;
pub const mps_option_key_MPS_FLAG_UNDEFINED: mps_option_key = 0;
pub const mps_option_key_MPS_FLAG_INTEGER: mps_option_key = 1;
pub const mps_option_key_MPS_FLAG_REAL: mps_option_key = 2;
pub const mps_option_key_MPS_FLAG_COMPLEX: mps_option_key = 3;
pub const mps_option_key_MPS_FLAG_RATIONAL: mps_option_key = 4;
pub const mps_option_key_MPS_FLAG_FP: mps_option_key = 5;
pub const mps_option_key_MPS_FLAG_SECULAR: mps_option_key = 6;
pub const mps_option_key_MPS_FLAG_MONOMIAL: mps_option_key = 7;
pub const mps_option_key_MPS_FLAG_DENSE: mps_option_key = 8;
pub const mps_option_key_MPS_FLAG_SPARSE: mps_option_key = 9;
pub const mps_option_key_MPS_KEY_DEGREE: mps_option_key = 10;
pub const mps_option_key_MPS_KEY_PRECISION: mps_option_key = 11;
pub const mps_option_key_MPS_FLAG_CHEBYSHEV: mps_option_key = 12;
#[doc = " @brief Key for options parsed from the input source file.\n Key that don't need values could exists (these are boolean flags,\n actually)."]
pub type mps_option_key = i32;
pub const mps_structure_MPS_STRUCTURE_REAL_INTEGER: mps_structure = 0;
pub const mps_structure_MPS_STRUCTURE_REAL_RATIONAL: mps_structure = 1;
pub const mps_structure_MPS_STRUCTURE_REAL_FP: mps_structure = 2;
pub const mps_structure_MPS_STRUCTURE_REAL_BIGFLOAT: mps_structure = 3;
pub const mps_structure_MPS_STRUCTURE_COMPLEX_INTEGER: mps_structure = 4;
pub const mps_structure_MPS_STRUCTURE_COMPLEX_RATIONAL: mps_structure = 5;
pub const mps_structure_MPS_STRUCTURE_COMPLEX_FP: mps_structure = 6;
pub const mps_structure_MPS_STRUCTURE_COMPLEX_BIGFLOAT: mps_structure = 7;
pub const mps_structure_MPS_STRUCTURE_UNKNOWN: mps_structure = 8;
#[doc = " @brief Definition of various algebraic structure that\n MPSolve can use as input.\n\n Precisely, integer, rational and floating point, either real or\n complex, can be treated in input."]
pub type mps_structure = i32;
pub const mps_density_MPS_DENSITY_DENSE: mps_density = 0;
pub const mps_density_MPS_DENSITY_SPARSE: mps_density = 1;
pub const mps_density_MPS_DENSITY_USER: mps_density = 2;
#[doc = " @brief Density of the polynomial, or\n MPS_DENSITY_USER if density doesn't make sense\n since user routines are provided to compute\n the newton fraction."]
pub type mps_density = i32;
pub const mps_output_format_MPS_OUTPUT_FORMAT_COMPACT: mps_output_format = 0;
pub const mps_output_format_MPS_OUTPUT_FORMAT_GNUPLOT: mps_output_format = 1;
pub const mps_output_format_MPS_OUTPUT_FORMAT_GNUPLOT_FULL: mps_output_format = 2;
pub const mps_output_format_MPS_OUTPUT_FORMAT_BARE: mps_output_format = 3;
pub const mps_output_format_MPS_OUTPUT_FORMAT_FULL: mps_output_format = 4;
pub const mps_output_format_MPS_OUTPUT_FORMAT_VERBOSE: mps_output_format = 5;
#[doc = " @brief Desired output format for the roots."]
pub type mps_output_format = i32;
pub const mps_output_goal_MPS_OUTPUT_GOAL_ISOLATE: mps_output_goal = 0;
pub const mps_output_goal_MPS_OUTPUT_GOAL_APPROXIMATE: mps_output_goal = 1;
pub const mps_output_goal_MPS_OUTPUT_GOAL_COUNT: mps_output_goal = 2;
#[doc = " @brief Goal to reach before returning the result."]
pub type mps_output_goal = i32;
#[doc = " @brief The whole complex plane."]
pub const mps_search_set_MPS_SEARCH_SET_COMPLEX_PLANE: mps_search_set = 0;
#[doc = " @brief Complex numbers with a positive real part."]
pub const mps_search_set_MPS_SEARCH_SET_POSITIVE_REAL_PART: mps_search_set = 1;
#[doc = " @brief Complex numbers with a negative real part."]
pub const mps_search_set_MPS_SEARCH_SET_NEGATIVE_REAL_PART: mps_search_set = 2;
#[doc = " @brief Complex numbers with a positive imaginary part."]
pub const mps_search_set_MPS_SEARCH_SET_POSITIVE_IMAG_PART: mps_search_set = 3;
#[doc = " @brief Complex numbers with a negative real part."]
pub const mps_search_set_MPS_SEARCH_SET_NEGATIVE_IMAG_PART: mps_search_set = 4;
#[doc = " @brief Complex numbers in the unitary disc\n \\f$S = \\{ z \\: | \\: \\lvert z \\rvert \\leq 1 \\}\\f$"]
pub const mps_search_set_MPS_SEARCH_SET_UNITARY_DISC: mps_search_set = 5;
#[doc = " @brief Complex number out of the unitary disc\n \\f$S = \\{ z \\: | \\: \\lvert z \\rvert \\leq 1 \\}\\f$"]
pub const mps_search_set_MPS_SEARCH_SET_UNITARY_DISC_COMPL: mps_search_set = 6;
#[doc = " @brief Only real roots."]
pub const mps_search_set_MPS_SEARCH_SET_REAL: mps_search_set = 7;
#[doc = " @brief Only pure imaginary roots."]
pub const mps_search_set_MPS_SEARCH_SET_IMAG: mps_search_set = 8;
#[doc = " @brief Custom set specified by the user."]
pub const mps_search_set_MPS_SEARCH_SET_CUSTOM: mps_search_set = 9;
#[doc = " @brief Set in which the roots are searched."]
pub type mps_search_set = i32;
pub const mps_representation_MPS_REPRESENTATION_SECULAR: mps_representation = 0;
pub const mps_representation_MPS_REPRESENTATION_MONOMIAL: mps_representation = 1;
pub const mps_representation_MPS_REPRESENTATION_CHEBYSHEV: mps_representation = 2;
#[doc = " @brief Representation chosen for the polynomial"]
pub type mps_representation = i32;
pub const mps_starting_strategy_MPS_STARTING_STRATEGY_DEFAULT: mps_starting_strategy = 0;
pub const mps_starting_strategy_MPS_STARTING_STRATEGY_RECURSIVE: mps_starting_strategy = 1;
pub const mps_starting_strategy_MPS_STARTING_STRATEGY_FILE: mps_starting_strategy = 2;
#[doc = " @brief Strategy used to select the starting approximations."]
pub type mps_starting_strategy = i32;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t
{
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1
{
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1()
{
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t()
{
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t
{
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t()
{
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t
{
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t()
{
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt
{
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data
{
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE
{
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE()
{
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cplx_struct
{
    pub r: f64,
    pub i: f64,
}
#[test]
fn bindgen_test_layout___cplx_struct()
{
    const UNINIT: ::std::mem::MaybeUninit<__cplx_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__cplx_struct>(),
        16usize,
        concat!("Size of: ", stringify!(__cplx_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__cplx_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__cplx_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__cplx_struct),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__cplx_struct),
            "::",
            stringify!(i)
        )
    );
}
pub type cplx_t = [__cplx_struct; 1usize];
pub type cplx_cp = *const __cplx_struct;
extern "C" {
    pub static cplx_zero: cplx_t;
}
extern "C" {
    pub static cplx_one: cplx_t;
}
extern "C" {
    pub static cplx_i: cplx_t;
}
extern "C" {
    pub fn cplx_d(temp_cplx: *mut __cplx_struct, r: f64, i: f64);
}
extern "C" {
    pub fn cplx_clear(x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_set(rx: *mut __cplx_struct, x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_set_d(x: *mut __cplx_struct, dr: f64, di: f64);
}
extern "C" {
    pub fn cplx_set_str(
        x: *mut __cplx_struct,
        s: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cplx_check_fpe(x: *mut __cplx_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cplx_get_d(dr: *mut f64, di: *mut f64, x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_get_str(
        s: *mut ::std::os::raw::c_char,
        x: *mut __cplx_struct,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cplx_neg(rx: *mut __cplx_struct, x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_con(rx: *mut __cplx_struct, x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_smod(x: *mut __cplx_struct) -> f64;
}
extern "C" {
    pub fn cplx_mod(x: *mut __cplx_struct) -> f64;
}
extern "C" {
    pub fn cplx_inv(rx: *mut __cplx_struct, x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_sqr(rx: *mut __cplx_struct, x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_rot(rx: *mut __cplx_struct, x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_flip(rx: *mut __cplx_struct, x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_add(rx: *mut __cplx_struct, x1: *mut __cplx_struct, x2: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_sub(rx: *mut __cplx_struct, x1: *mut __cplx_struct, x2: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_mul(rx: *mut __cplx_struct, x1: *mut __cplx_struct, x2: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_div(rx: *mut __cplx_struct, x1: *mut __cplx_struct, x2: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_mul_d(rx: *mut __cplx_struct, x: *mut __cplx_struct, d: f64);
}
extern "C" {
    pub fn cplx_div_d(rx: *mut __cplx_struct, x: *mut __cplx_struct, d: f64);
}
extern "C" {
    pub fn cplx_pow_si(rx: *mut __cplx_struct, x: *mut __cplx_struct, i: ::std::os::raw::c_long);
}
extern "C" {
    pub fn cplx_swap(x1: *mut __cplx_struct, x2: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_neg_eq(x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_con_eq(x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_inv_eq(x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_sqr_eq(x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_rot_eq(x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_flip_eq(x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_add_eq(rx: *mut __cplx_struct, x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_sub_eq(rx: *mut __cplx_struct, x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_mul_eq(rx: *mut __cplx_struct, x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_div_eq(rx: *mut __cplx_struct, x: *mut __cplx_struct);
}
extern "C" {
    pub fn cplx_mul_eq_d(x: *mut __cplx_struct, d: f64);
}
extern "C" {
    pub fn cplx_div_eq_d(x: *mut __cplx_struct, d: f64);
}
extern "C" {
    pub fn cplx_pow_eq_si(x: *mut __cplx_struct, i: ::std::os::raw::c_long);
}
extern "C" {
    pub fn cplx_eq_zero(x: *mut __cplx_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cplx_eq(x1: *mut __cplx_struct, x2: *mut __cplx_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cplx_ne(x1: *mut __cplx_struct, x2: *mut __cplx_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cplx_out_str_u(f: *mut FILE, x: *mut __cplx_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cplx_out_str(f: *mut FILE, x: *mut __cplx_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cplx_inp_str_u(x: *mut __cplx_struct, f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cplx_inp_str(x: *mut __cplx_struct, f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cplx_vinit(v: *mut cplx_t, size: ::std::os::raw::c_long);
}
#[doc = "              rdpe_t type                               **"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __rdpe_struct
{
    pub m: f64,
    pub e: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout___rdpe_struct()
{
    const UNINIT: ::std::mem::MaybeUninit<__rdpe_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__rdpe_struct>(),
        16usize,
        concat!("Size of: ", stringify!(__rdpe_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__rdpe_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__rdpe_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__rdpe_struct),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__rdpe_struct),
            "::",
            stringify!(e)
        )
    );
}
pub type rdpe_t = [__rdpe_struct; 1usize];
pub type rdpe_cp = *const __rdpe_struct;
extern "C" {
    pub static rdpe_zero: rdpe_t;
}
extern "C" {
    pub static rdpe_one: rdpe_t;
}
extern "C" {
    pub static rdpe_maxd: rdpe_t;
}
extern "C" {
    pub static rdpe_mind: rdpe_t;
}
extern "C" {
    pub static RDPE_MAX: rdpe_t;
}
extern "C" {
    pub static RDPE_MIN: rdpe_t;
}
extern "C" {
    pub static RDPE_BIG: rdpe_t;
}
extern "C" {
    pub fn rdpe_d(temp_rdpe: *mut __rdpe_struct, d: f64);
}
extern "C" {
    pub fn rdpe_2dl(temp_rdpe: *mut __rdpe_struct, d: f64, l: ::std::os::raw::c_long);
}
extern "C" {
    pub fn rdpe_clear(e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_set(re: *mut __rdpe_struct, e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_set_d(e: *mut __rdpe_struct, d: f64);
}
extern "C" {
    pub fn rdpe_set_dl(e: *mut __rdpe_struct, d: f64, l: ::std::os::raw::c_long);
}
extern "C" {
    pub fn rdpe_set_2dl(e: *mut __rdpe_struct, d: f64, l: ::std::os::raw::c_long);
}
extern "C" {
    pub fn rdpe_set_str(
        e: *mut __rdpe_struct,
        s: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdpe_get_d(e: *mut __rdpe_struct) -> f64;
}
extern "C" {
    pub fn rdpe_get_dl(d: *mut f64, l: *mut ::std::os::raw::c_long, e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_get_2dl(d: *mut f64, l: *mut ::std::os::raw::c_long, e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_get_str(
        s: *mut ::std::os::raw::c_char,
        e: *mut __rdpe_struct,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rdpe_neg(re: *mut __rdpe_struct, e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_abs(re: *mut __rdpe_struct, e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_inv(re: *mut __rdpe_struct, e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_sqr(re: *mut __rdpe_struct, e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_sqrt(re: *mut __rdpe_struct, e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_log(e: *mut __rdpe_struct) -> f64;
}
extern "C" {
    pub fn rdpe_log10(e: *mut __rdpe_struct) -> f64;
}
extern "C" {
    pub fn rdpe_exp(re: *mut __rdpe_struct, e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_add(re: *mut __rdpe_struct, e1: *mut __rdpe_struct, e2: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_sub(re: *mut __rdpe_struct, e1: *mut __rdpe_struct, e2: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_mul(re: *mut __rdpe_struct, e1: *mut __rdpe_struct, e2: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_div(re: *mut __rdpe_struct, e1: *mut __rdpe_struct, e2: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_add_d(re: *mut __rdpe_struct, e: *mut __rdpe_struct, d: f64);
}
extern "C" {
    pub fn rdpe_sub_d(re: *mut __rdpe_struct, e: *mut __rdpe_struct, d: f64);
}
extern "C" {
    pub fn rdpe_mul_d(re: *mut __rdpe_struct, e: *mut __rdpe_struct, d: f64);
}
extern "C" {
    pub fn rdpe_mul_2exp(re: *mut __rdpe_struct, e: *mut __rdpe_struct, i: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn rdpe_div_d(re: *mut __rdpe_struct, e: *mut __rdpe_struct, d: f64);
}
extern "C" {
    pub fn rdpe_div_2exp(re: *mut __rdpe_struct, e: *mut __rdpe_struct, i: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn rdpe_pow_d(re: *mut __rdpe_struct, e: *mut __rdpe_struct, d: f64);
}
extern "C" {
    pub fn rdpe_pow_si(re: *mut __rdpe_struct, e: *mut __rdpe_struct, i: ::std::os::raw::c_long);
}
extern "C" {
    pub fn rdpe_fac_ui(e: *mut __rdpe_struct, n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn rdpe_swap(e1: *mut __rdpe_struct, e2: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_neg_eq(e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_abs_eq(e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_inv_eq(e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_sqr_eq(e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_sqrt_eq(e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_exp_eq(e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_add_eq(re: *mut __rdpe_struct, e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_sub_eq(re: *mut __rdpe_struct, e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_mul_eq(re: *mut __rdpe_struct, e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_div_eq(re: *mut __rdpe_struct, e: *mut __rdpe_struct);
}
extern "C" {
    pub fn rdpe_add_eq_d(e: *mut __rdpe_struct, d: f64);
}
extern "C" {
    pub fn rdpe_sub_eq_d(e: *mut __rdpe_struct, d: f64);
}
extern "C" {
    pub fn rdpe_mul_eq_d(e: *mut __rdpe_struct, d: f64);
}
extern "C" {
    pub fn rdpe_mul_eq_2exp(e: *mut __rdpe_struct, i: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn rdpe_div_eq_d(e: *mut __rdpe_struct, d: f64);
}
extern "C" {
    pub fn rdpe_div_eq_2exp(e: *mut __rdpe_struct, i: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn rdpe_pow_eq_d(e: *mut __rdpe_struct, d: f64);
}
extern "C" {
    pub fn rdpe_pow_eq_si(e: *mut __rdpe_struct, i: ::std::os::raw::c_long);
}
extern "C" {
    pub fn rdpe_cmp(e1: *mut __rdpe_struct, e2: *mut __rdpe_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdpe_sgn(e: *mut __rdpe_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdpe_eq_zero(e: *mut __rdpe_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdpe_eq(e1: *mut __rdpe_struct, e2: *mut __rdpe_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdpe_ne(e1: *mut __rdpe_struct, e2: *mut __rdpe_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdpe_lt(e1: *mut __rdpe_struct, e2: *mut __rdpe_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdpe_le(e1: *mut __rdpe_struct, e2: *mut __rdpe_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdpe_gt(e1: *mut __rdpe_struct, e2: *mut __rdpe_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdpe_ge(e1: *mut __rdpe_struct, e2: *mut __rdpe_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdpe_out_str_u(f: *mut FILE, e: *mut __rdpe_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdpe_out_str(f: *mut FILE, e: *mut __rdpe_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdpe_inp_str_u(e: *mut __rdpe_struct, f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdpe_inp_str(e: *mut __rdpe_struct, f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdpe_inp_str_flex(e: *mut __rdpe_struct, f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdpe_vinit(v: *mut rdpe_t, size: ::std::os::raw::c_long);
}
#[doc = "              gdpe_t functions                          **"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gdpe_struct
{
    pub r: rdpe_t,
    pub eps: rdpe_t,
    pub rel_eps: rdpe_t,
}
#[test]
fn bindgen_test_layout___gdpe_struct()
{
    const UNINIT: ::std::mem::MaybeUninit<__gdpe_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__gdpe_struct>(),
        48usize,
        concat!("Size of: ", stringify!(__gdpe_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__gdpe_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__gdpe_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__gdpe_struct),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eps) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__gdpe_struct),
            "::",
            stringify!(eps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rel_eps) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__gdpe_struct),
            "::",
            stringify!(rel_eps)
        )
    );
}
pub type gdpe_t = [__gdpe_struct; 1usize];
extern "C" {
    pub fn gdpe_add(res: *mut __gdpe_struct, g1: *mut __gdpe_struct, g2: *mut __gdpe_struct);
}
extern "C" {
    pub fn gdpe_sub(res: *mut __gdpe_struct, g1: *mut __gdpe_struct, g2: *mut __gdpe_struct);
}
extern "C" {
    pub fn gdpe_mul(res: *mut __gdpe_struct, g1: *mut __gdpe_struct, g2: *mut __gdpe_struct);
}
extern "C" {
    pub fn gdpe_div(res: *mut __gdpe_struct, g1: *mut __gdpe_struct, g2: *mut __gdpe_struct);
}
#[doc = "              cdpe_t functions                          **"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __cdpe_struct
{
    pub r: rdpe_t,
    pub i: rdpe_t,
}
#[test]
fn bindgen_test_layout___cdpe_struct()
{
    const UNINIT: ::std::mem::MaybeUninit<__cdpe_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__cdpe_struct>(),
        32usize,
        concat!("Size of: ", stringify!(__cdpe_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__cdpe_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__cdpe_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__cdpe_struct),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__cdpe_struct),
            "::",
            stringify!(i)
        )
    );
}
pub type cdpe_t = [__cdpe_struct; 1usize];
pub type cdpe_cp = *const __cdpe_struct;
extern "C" {
    pub static cdpe_zero: cdpe_t;
}
extern "C" {
    pub static cdpe_one: cdpe_t;
}
extern "C" {
    pub static cdpe_i: cdpe_t;
}
extern "C" {
    pub fn cdpe_d(temp_cdpe: *mut __cdpe_struct, r: f64, i: f64);
}
extern "C" {
    pub fn cdpe_x(temp_cdpe: *mut __cdpe_struct, x: *mut __cplx_struct);
}
extern "C" {
    pub fn cdpe_e(temp_cdpe: *mut __cdpe_struct, er: *mut __rdpe_struct, ei: *mut __rdpe_struct);
}
extern "C" {
    pub fn cdpe_2dl(
        temp_cdpe: *mut __cdpe_struct,
        dr: f64,
        lr: ::std::os::raw::c_long,
        di: f64,
        li: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn cdpe_clear(c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_set(rc: *mut __cdpe_struct, c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_set_e(c: *mut __cdpe_struct, er: *mut __rdpe_struct, ei: *mut __rdpe_struct);
}
extern "C" {
    pub fn cdpe_set_x(c: *mut __cdpe_struct, x: *mut __cplx_struct);
}
extern "C" {
    pub fn cdpe_set_d(c: *mut __cdpe_struct, dr: f64, di: f64);
}
extern "C" {
    pub fn cdpe_set_dl(
        c: *mut __cdpe_struct,
        dr: f64,
        lr: ::std::os::raw::c_long,
        di: f64,
        li: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn cdpe_set_2dl(
        c: *mut __cdpe_struct,
        dr: f64,
        lr: ::std::os::raw::c_long,
        di: f64,
        li: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn cdpe_set_str(
        c: *mut __cdpe_struct,
        s: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cdpe_get_e(er: *mut __rdpe_struct, ei: *mut __rdpe_struct, c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_get_x(x: *mut __cplx_struct, c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_get_d(dr: *mut f64, di: *mut f64, c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_get_str(
        s: *mut ::std::os::raw::c_char,
        c: *mut __cdpe_struct,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cdpe_neg(rc: *mut __cdpe_struct, c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_con(rc: *mut __cdpe_struct, c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_smod(e: *mut __rdpe_struct, c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_mod(e: *mut __rdpe_struct, c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_inv(rc: *mut __cdpe_struct, c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_sqr(rc: *mut __cdpe_struct, c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_rot(rc: *mut __cdpe_struct, c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_flip(rc: *mut __cdpe_struct, c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_add(rc: *mut __cdpe_struct, c1: *mut __cdpe_struct, c2: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_sub(rc: *mut __cdpe_struct, c1: *mut __cdpe_struct, c2: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_mul(rc: *mut __cdpe_struct, c1: *mut __cdpe_struct, c2: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_div(rc: *mut __cdpe_struct, c1: *mut __cdpe_struct, c2: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_mul_e(rc: *mut __cdpe_struct, c: *mut __cdpe_struct, e: *mut __rdpe_struct);
}
extern "C" {
    pub fn cdpe_mul_x(rc: *mut __cdpe_struct, c: *mut __cdpe_struct, x: *mut __cplx_struct);
}
extern "C" {
    pub fn cdpe_mul_d(rc: *mut __cdpe_struct, c: *mut __cdpe_struct, d: f64);
}
extern "C" {
    pub fn cdpe_mul_2exp(rc: *mut __cdpe_struct, c: *mut __cdpe_struct, i: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn cdpe_div_e(rc: *mut __cdpe_struct, c: *mut __cdpe_struct, e: *mut __rdpe_struct);
}
extern "C" {
    pub fn cdpe_div_d(rc: *mut __cdpe_struct, c: *mut __cdpe_struct, d: f64);
}
extern "C" {
    pub fn cdpe_div_2exp(rc: *mut __cdpe_struct, c: *mut __cdpe_struct, i: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn cdpe_pow_si(rc: *mut __cdpe_struct, c: *mut __cdpe_struct, i: ::std::os::raw::c_long);
}
extern "C" {
    pub fn cdpe_neg_eq(c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_con_eq(c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_inv_eq(c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_sqr_eq(c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_rot_eq(c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_flip_eq(c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_add_eq(rc: *mut __cdpe_struct, c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_sub_eq(rc: *mut __cdpe_struct, c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_mul_eq(rc: *mut __cdpe_struct, c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_div_eq(rc: *mut __cdpe_struct, c: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_mul_eq_e(c: *mut __cdpe_struct, e: *mut __rdpe_struct);
}
extern "C" {
    pub fn cdpe_mul_eq_x(c: *mut __cdpe_struct, x: *mut __cplx_struct);
}
extern "C" {
    pub fn cdpe_mul_eq_d(c: *mut __cdpe_struct, d: f64);
}
extern "C" {
    pub fn cdpe_mul_eq_2exp(c: *mut __cdpe_struct, i: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn cdpe_div_eq_e(c: *mut __cdpe_struct, e: *mut __rdpe_struct);
}
extern "C" {
    pub fn cdpe_div_eq_d(c: *mut __cdpe_struct, d: f64);
}
extern "C" {
    pub fn cdpe_div_eq_2exp(c: *mut __cdpe_struct, i: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn cdpe_pow_eq_si(c: *mut __cdpe_struct, i: ::std::os::raw::c_long);
}
extern "C" {
    pub fn cdpe_swap(c1: *mut __cdpe_struct, c2: *mut __cdpe_struct);
}
extern "C" {
    pub fn cdpe_eq_zero(c: *mut __cdpe_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cdpe_eq(c1: *mut __cdpe_struct, c2: *mut __cdpe_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cdpe_ne(c1: *mut __cdpe_struct, c2: *mut __cdpe_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cdpe_out_str_u(f: *mut FILE, c: *mut __cdpe_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cdpe_out_str(f: *mut FILE, c: *mut __cdpe_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cdpe_inp_str_u(c: *mut __cdpe_struct, f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cdpe_inp_str(c: *mut __cdpe_struct, f: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cdpe_vinit(v: *mut cdpe_t, size: ::std::os::raw::c_long);
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t
{
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t()
{
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type mp_limb_t = ::std::os::raw::c_ulong;
pub type mp_limb_signed_t = ::std::os::raw::c_long;
pub type mp_bitcnt_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mpz_struct
{
    pub _mp_alloc: ::std::os::raw::c_int,
    pub _mp_size: ::std::os::raw::c_int,
    pub _mp_d: *mut mp_limb_t,
}
#[test]
fn bindgen_test_layout___mpz_struct()
{
    const UNINIT: ::std::mem::MaybeUninit<__mpz_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mpz_struct>(),
        16usize,
        concat!("Size of: ", stringify!(__mpz_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__mpz_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__mpz_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mp_alloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpz_struct),
            "::",
            stringify!(_mp_alloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mp_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpz_struct),
            "::",
            stringify!(_mp_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mp_d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpz_struct),
            "::",
            stringify!(_mp_d)
        )
    );
}
pub type MP_INT = __mpz_struct;
pub type mpz_t = [__mpz_struct; 1usize];
pub type mp_ptr = *mut mp_limb_t;
pub type mp_srcptr = *const mp_limb_t;
pub type mp_size_t = ::std::os::raw::c_long;
pub type mp_exp_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mpq_struct
{
    pub _mp_num: __mpz_struct,
    pub _mp_den: __mpz_struct,
}
#[test]
fn bindgen_test_layout___mpq_struct()
{
    const UNINIT: ::std::mem::MaybeUninit<__mpq_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mpq_struct>(),
        32usize,
        concat!("Size of: ", stringify!(__mpq_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__mpq_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__mpq_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mp_num) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpq_struct),
            "::",
            stringify!(_mp_num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mp_den) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpq_struct),
            "::",
            stringify!(_mp_den)
        )
    );
}
pub type MP_RAT = __mpq_struct;
pub type mpq_t = [__mpq_struct; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mpf_struct
{
    pub _mp_prec: ::std::os::raw::c_int,
    pub _mp_size: ::std::os::raw::c_int,
    pub _mp_exp: mp_exp_t,
    pub _mp_d: *mut mp_limb_t,
}
#[test]
fn bindgen_test_layout___mpf_struct()
{
    const UNINIT: ::std::mem::MaybeUninit<__mpf_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mpf_struct>(),
        24usize,
        concat!("Size of: ", stringify!(__mpf_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__mpf_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__mpf_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mp_prec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpf_struct),
            "::",
            stringify!(_mp_prec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mp_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpf_struct),
            "::",
            stringify!(_mp_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mp_exp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpf_struct),
            "::",
            stringify!(_mp_exp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mp_d) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpf_struct),
            "::",
            stringify!(_mp_d)
        )
    );
}
pub type mpf_t = [__mpf_struct; 1usize];
pub const gmp_randalg_t_GMP_RAND_ALG_DEFAULT: gmp_randalg_t = 0;
pub const gmp_randalg_t_GMP_RAND_ALG_LC: gmp_randalg_t = 0;
pub type gmp_randalg_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __gmp_randstate_struct
{
    pub _mp_seed: mpz_t,
    pub _mp_alg: gmp_randalg_t,
    pub _mp_algdata: __gmp_randstate_struct__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __gmp_randstate_struct__bindgen_ty_1
{
    pub _mp_lc: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___gmp_randstate_struct__bindgen_ty_1()
{
    const UNINIT: ::std::mem::MaybeUninit<__gmp_randstate_struct__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__gmp_randstate_struct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__gmp_randstate_struct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__gmp_randstate_struct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__gmp_randstate_struct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mp_lc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__gmp_randstate_struct__bindgen_ty_1),
            "::",
            stringify!(_mp_lc)
        )
    );
}
#[test]
fn bindgen_test_layout___gmp_randstate_struct()
{
    const UNINIT: ::std::mem::MaybeUninit<__gmp_randstate_struct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__gmp_randstate_struct>(),
        32usize,
        concat!("Size of: ", stringify!(__gmp_randstate_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__gmp_randstate_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__gmp_randstate_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mp_seed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__gmp_randstate_struct),
            "::",
            stringify!(_mp_seed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mp_alg) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__gmp_randstate_struct),
            "::",
            stringify!(_mp_alg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mp_algdata) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__gmp_randstate_struct),
            "::",
            stringify!(_mp_algdata)
        )
    );
}
pub type gmp_randstate_t = [__gmp_randstate_struct; 1usize];
pub type mpz_srcptr = *const __mpz_struct;
pub type mpz_ptr = *mut __mpz_struct;
pub type mpf_srcptr = *const __mpf_struct;
pub type mpf_ptr = *mut __mpf_struct;
pub type mpq_srcptr = *const __mpq_struct;
pub type mpq_ptr = *mut __mpq_struct;
pub type gmp_randstate_ptr = *mut __gmp_randstate_struct;
pub type gmp_randstate_srcptr = *const __gmp_randstate_struct;
extern "C" {
    pub fn __gmp_set_memory_functions(
        arg1: ::std::option::Option<
            unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void,
        >,
        arg2: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: usize,
                arg3: usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
        arg3: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: usize),
        >,
    );
}
extern "C" {
    pub fn __gmp_get_memory_functions(
        arg1: *mut ::std::option::Option<
            unsafe extern "C" fn(arg1: usize) -> *mut ::std::os::raw::c_void,
        >,
        arg2: *mut ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: usize,
                arg3: usize,
            ) -> *mut ::std::os::raw::c_void,
        >,
        arg3: *mut ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void, arg2: usize),
        >,
    );
}
extern "C" {
    pub static __gmp_bits_per_limb: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __gmp_errno: ::std::os::raw::c_int;
}
extern "C" {
    pub static __gmp_version: *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn __gmp_randinit(arg1: gmp_randstate_ptr, arg2: gmp_randalg_t, ...);
}
extern "C" {
    pub fn __gmp_randinit_default(arg1: gmp_randstate_ptr);
}
extern "C" {
    pub fn __gmp_randinit_lc_2exp(
        arg1: gmp_randstate_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
        arg4: mp_bitcnt_t,
    );
}
extern "C" {
    pub fn __gmp_randinit_lc_2exp_size(
        arg1: gmp_randstate_ptr,
        arg2: mp_bitcnt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_randinit_mt(arg1: gmp_randstate_ptr);
}
extern "C" {
    pub fn __gmp_randinit_set(arg1: gmp_randstate_ptr, arg2: gmp_randstate_srcptr);
}
extern "C" {
    pub fn __gmp_randseed(arg1: gmp_randstate_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmp_randseed_ui(arg1: gmp_randstate_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmp_randclear(arg1: gmp_randstate_ptr);
}
extern "C" {
    pub fn __gmp_urandomb_ui(
        arg1: gmp_randstate_ptr,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmp_urandomm_ui(
        arg1: gmp_randstate_ptr,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmp_asprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_fprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_printf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_snprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_sprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_vasprintf(
        arg1: *mut *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_vfprintf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_vprintf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_vsnprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: usize,
        arg3: *const ::std::os::raw::c_char,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_vsprintf(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_fscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_scanf(arg1: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_sscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_vfscanf(
        arg1: *mut FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_vscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmp_vsscanf(
        arg1: *const ::std::os::raw::c_char,
        arg2: *const ::std::os::raw::c_char,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_realloc(arg1: mpz_ptr, arg2: mp_size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __gmpz_add(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_add_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_addmul(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_addmul_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_and(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_array_init(arg1: mpz_ptr, arg2: mp_size_t, arg3: mp_size_t);
}
extern "C" {
    pub fn __gmpz_bin_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_bin_uiui(
        arg1: mpz_ptr,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __gmpz_cdiv_q(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_cdiv_q_2exp(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_cdiv_q_ui(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_cdiv_qr(arg1: mpz_ptr, arg2: mpz_ptr, arg3: mpz_srcptr, arg4: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_cdiv_qr_ui(
        arg1: mpz_ptr,
        arg2: mpz_ptr,
        arg3: mpz_srcptr,
        arg4: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_cdiv_r(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_cdiv_r_2exp(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_cdiv_r_ui(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_cdiv_ui(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_clear(arg1: mpz_ptr);
}
extern "C" {
    pub fn __gmpz_clears(arg1: mpz_ptr, ...);
}
extern "C" {
    pub fn __gmpz_clrbit(arg1: mpz_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_cmp(arg1: mpz_srcptr, arg2: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmp_d(arg1: mpz_srcptr, arg2: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmp_si(arg1: mpz_srcptr, arg2: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmp_ui(arg1: mpz_srcptr, arg2: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmpabs(arg1: mpz_srcptr, arg2: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmpabs_d(arg1: mpz_srcptr, arg2: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_cmpabs_ui(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_com(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_combit(arg1: mpz_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_congruent_p(
        arg1: mpz_srcptr,
        arg2: mpz_srcptr,
        arg3: mpz_srcptr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_congruent_2exp_p(
        arg1: mpz_srcptr,
        arg2: mpz_srcptr,
        arg3: mp_bitcnt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_congruent_ui_p(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_divexact(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_divexact_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_divisible_p(arg1: mpz_srcptr, arg2: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_divisible_ui_p(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_divisible_2exp_p(arg1: mpz_srcptr, arg2: mp_bitcnt_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_dump(arg1: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_export(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *mut usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: ::std::os::raw::c_int,
        arg6: usize,
        arg7: mpz_srcptr,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn __gmpz_fac_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_2fac_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_mfac_uiui(
        arg1: mpz_ptr,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __gmpz_primorial_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_fdiv_q(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_fdiv_q_2exp(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_fdiv_q_ui(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_fdiv_qr(arg1: mpz_ptr, arg2: mpz_ptr, arg3: mpz_srcptr, arg4: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_fdiv_qr_ui(
        arg1: mpz_ptr,
        arg2: mpz_ptr,
        arg3: mpz_srcptr,
        arg4: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_fdiv_r(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_fdiv_r_2exp(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_fdiv_r_ui(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_fdiv_ui(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_fib_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_fib2_ui(arg1: mpz_ptr, arg2: mpz_ptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_fits_sint_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_fits_slong_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_fits_sshort_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_gcd(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_gcd_ui(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_gcdext(
        arg1: mpz_ptr,
        arg2: mpz_ptr,
        arg3: mpz_ptr,
        arg4: mpz_srcptr,
        arg5: mpz_srcptr,
    );
}
extern "C" {
    pub fn __gmpz_get_d(arg1: mpz_srcptr) -> f64;
}
extern "C" {
    pub fn __gmpz_get_d_2exp(arg1: *mut ::std::os::raw::c_long, arg2: mpz_srcptr) -> f64;
}
extern "C" {
    pub fn __gmpz_get_si(arg1: mpz_srcptr) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __gmpz_get_str(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: mpz_srcptr,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __gmpz_hamdist(arg1: mpz_srcptr, arg2: mpz_srcptr) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpz_import(
        arg1: mpz_ptr,
        arg2: usize,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: ::std::os::raw::c_int,
        arg6: usize,
        arg7: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn __gmpz_init(arg1: mpz_ptr);
}
extern "C" {
    pub fn __gmpz_init2(arg1: mpz_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_inits(arg1: mpz_ptr, ...);
}
extern "C" {
    pub fn __gmpz_init_set(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_init_set_d(arg1: mpz_ptr, arg2: f64);
}
extern "C" {
    pub fn __gmpz_init_set_si(arg1: mpz_ptr, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn __gmpz_init_set_str(
        arg1: mpz_ptr,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_init_set_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_inp_raw(arg1: mpz_ptr, arg2: *mut FILE) -> usize;
}
extern "C" {
    pub fn __gmpz_inp_str(arg1: mpz_ptr, arg2: *mut FILE, arg3: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn __gmpz_invert(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: mpz_srcptr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_ior(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_jacobi(arg1: mpz_srcptr, arg2: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_kronecker_si(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_kronecker_ui(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_si_kronecker(
        arg1: ::std::os::raw::c_long,
        arg2: mpz_srcptr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_ui_kronecker(
        arg1: ::std::os::raw::c_ulong,
        arg2: mpz_srcptr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_lcm(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_lcm_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_lucnum_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_lucnum2_ui(arg1: mpz_ptr, arg2: mpz_ptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_millerrabin(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_mod(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_mul(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_mul_2exp(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_mul_si(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_long);
}
extern "C" {
    pub fn __gmpz_mul_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_nextprime(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_prevprime(arg1: mpz_ptr, arg2: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_out_raw(arg1: *mut FILE, arg2: mpz_srcptr) -> usize;
}
extern "C" {
    pub fn __gmpz_out_str(arg1: *mut FILE, arg2: ::std::os::raw::c_int, arg3: mpz_srcptr) -> usize;
}
extern "C" {
    pub fn __gmpz_perfect_power_p(arg1: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_pow_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_powm(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr, arg4: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_powm_sec(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr, arg4: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_powm_ui(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
        arg4: mpz_srcptr,
    );
}
extern "C" {
    pub fn __gmpz_probab_prime_p(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_random(arg1: mpz_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpz_random2(arg1: mpz_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpz_realloc2(arg1: mpz_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_remove(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpz_root(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_rootrem(
        arg1: mpz_ptr,
        arg2: mpz_ptr,
        arg3: mpz_srcptr,
        arg4: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __gmpz_rrandomb(arg1: mpz_ptr, arg2: gmp_randstate_ptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_scan0(arg1: mpz_srcptr, arg2: mp_bitcnt_t) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpz_scan1(arg1: mpz_srcptr, arg2: mp_bitcnt_t) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpz_set(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_set_d(arg1: mpz_ptr, arg2: f64);
}
extern "C" {
    pub fn __gmpz_set_f(arg1: mpz_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpz_set_si(arg1: mpz_ptr, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn __gmpz_set_str(
        arg1: mpz_ptr,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_set_ui(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_setbit(arg1: mpz_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_sizeinbase(arg1: mpz_srcptr, arg2: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn __gmpz_sqrt(arg1: mpz_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_sqrtrem(arg1: mpz_ptr, arg2: mpz_ptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_sub(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_sub_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_ui_sub(arg1: mpz_ptr, arg2: ::std::os::raw::c_ulong, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_submul(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_submul_ui(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpz_swap(arg1: mpz_ptr, arg2: mpz_ptr);
}
extern "C" {
    pub fn __gmpz_tdiv_ui(
        arg1: mpz_srcptr,
        arg2: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_tdiv_q(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_tdiv_q_2exp(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_tdiv_q_ui(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_tdiv_qr(arg1: mpz_ptr, arg2: mpz_ptr, arg3: mpz_srcptr, arg4: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_tdiv_qr_ui(
        arg1: mpz_ptr,
        arg2: mpz_ptr,
        arg3: mpz_srcptr,
        arg4: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_tdiv_r(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_tdiv_r_2exp(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_tdiv_r_ui(
        arg1: mpz_ptr,
        arg2: mpz_srcptr,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpz_tstbit(arg1: mpz_srcptr, arg2: mp_bitcnt_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpz_ui_pow_ui(
        arg1: mpz_ptr,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __gmpz_urandomb(arg1: mpz_ptr, arg2: gmp_randstate_ptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpz_urandomm(arg1: mpz_ptr, arg2: gmp_randstate_ptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_xor(arg1: mpz_ptr, arg2: mpz_srcptr, arg3: mpz_srcptr);
}
extern "C" {
    pub fn __gmpz_limbs_read(arg1: mpz_srcptr) -> mp_srcptr;
}
extern "C" {
    pub fn __gmpz_limbs_write(arg1: mpz_ptr, arg2: mp_size_t) -> mp_ptr;
}
extern "C" {
    pub fn __gmpz_limbs_modify(arg1: mpz_ptr, arg2: mp_size_t) -> mp_ptr;
}
extern "C" {
    pub fn __gmpz_limbs_finish(arg1: mpz_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpz_roinit_n(arg1: mpz_ptr, arg2: mp_srcptr, arg3: mp_size_t) -> mpz_srcptr;
}
extern "C" {
    pub fn __gmpq_add(arg1: mpq_ptr, arg2: mpq_srcptr, arg3: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_canonicalize(arg1: mpq_ptr);
}
extern "C" {
    pub fn __gmpq_clear(arg1: mpq_ptr);
}
extern "C" {
    pub fn __gmpq_clears(arg1: mpq_ptr, ...);
}
extern "C" {
    pub fn __gmpq_cmp(arg1: mpq_srcptr, arg2: mpq_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_cmp_si(
        arg1: mpq_srcptr,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_cmp_ui(
        arg1: mpq_srcptr,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_cmp_z(arg1: mpq_srcptr, arg2: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_div(arg1: mpq_ptr, arg2: mpq_srcptr, arg3: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_div_2exp(arg1: mpq_ptr, arg2: mpq_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpq_equal(arg1: mpq_srcptr, arg2: mpq_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_get_num(arg1: mpz_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_get_den(arg1: mpz_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_get_d(arg1: mpq_srcptr) -> f64;
}
extern "C" {
    pub fn __gmpq_get_str(
        arg1: *mut ::std::os::raw::c_char,
        arg2: ::std::os::raw::c_int,
        arg3: mpq_srcptr,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __gmpq_init(arg1: mpq_ptr);
}
extern "C" {
    pub fn __gmpq_inits(arg1: mpq_ptr, ...);
}
extern "C" {
    pub fn __gmpq_inp_str(arg1: mpq_ptr, arg2: *mut FILE, arg3: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn __gmpq_inv(arg1: mpq_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_mul(arg1: mpq_ptr, arg2: mpq_srcptr, arg3: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_mul_2exp(arg1: mpq_ptr, arg2: mpq_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpq_out_str(arg1: *mut FILE, arg2: ::std::os::raw::c_int, arg3: mpq_srcptr) -> usize;
}
extern "C" {
    pub fn __gmpq_set(arg1: mpq_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_set_d(arg1: mpq_ptr, arg2: f64);
}
extern "C" {
    pub fn __gmpq_set_den(arg1: mpq_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpq_set_f(arg1: mpq_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpq_set_num(arg1: mpq_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpq_set_si(
        arg1: mpq_ptr,
        arg2: ::std::os::raw::c_long,
        arg3: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __gmpq_set_str(
        arg1: mpq_ptr,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpq_set_ui(
        arg1: mpq_ptr,
        arg2: ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __gmpq_set_z(arg1: mpq_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpq_sub(arg1: mpq_ptr, arg2: mpq_srcptr, arg3: mpq_srcptr);
}
extern "C" {
    pub fn __gmpq_swap(arg1: mpq_ptr, arg2: mpq_ptr);
}
extern "C" {
    pub fn __gmpf_abs(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_add(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_add_ui(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_ceil(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_clear(arg1: mpf_ptr);
}
extern "C" {
    pub fn __gmpf_clears(arg1: mpf_ptr, ...);
}
extern "C" {
    pub fn __gmpf_cmp(arg1: mpf_srcptr, arg2: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_cmp_z(arg1: mpf_srcptr, arg2: mpz_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_cmp_d(arg1: mpf_srcptr, arg2: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_cmp_si(arg1: mpf_srcptr, arg2: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_cmp_ui(arg1: mpf_srcptr, arg2: ::std::os::raw::c_ulong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_div(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_div_2exp(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_div_ui(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_dump(arg1: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_eq(
        arg1: mpf_srcptr,
        arg2: mpf_srcptr,
        arg3: mp_bitcnt_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_sint_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_slong_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_sshort_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_uint_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_ulong_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_fits_ushort_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_floor(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_get_d(arg1: mpf_srcptr) -> f64;
}
extern "C" {
    pub fn __gmpf_get_d_2exp(arg1: *mut ::std::os::raw::c_long, arg2: mpf_srcptr) -> f64;
}
extern "C" {
    pub fn __gmpf_get_default_prec() -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpf_get_prec(arg1: mpf_srcptr) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpf_get_si(arg1: mpf_srcptr) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __gmpf_get_str(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut mp_exp_t,
        arg3: ::std::os::raw::c_int,
        arg4: usize,
        arg5: mpf_srcptr,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __gmpf_get_ui(arg1: mpf_srcptr) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __gmpf_init(arg1: mpf_ptr);
}
extern "C" {
    pub fn __gmpf_init2(arg1: mpf_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_inits(arg1: mpf_ptr, ...);
}
extern "C" {
    pub fn __gmpf_init_set(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_init_set_d(arg1: mpf_ptr, arg2: f64);
}
extern "C" {
    pub fn __gmpf_init_set_si(arg1: mpf_ptr, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn __gmpf_init_set_str(
        arg1: mpf_ptr,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_init_set_ui(arg1: mpf_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_inp_str(arg1: mpf_ptr, arg2: *mut FILE, arg3: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn __gmpf_integer_p(arg1: mpf_srcptr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_mul(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_mul_2exp(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_mul_ui(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_neg(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_out_str(
        arg1: *mut FILE,
        arg2: ::std::os::raw::c_int,
        arg3: usize,
        arg4: mpf_srcptr,
    ) -> usize;
}
extern "C" {
    pub fn __gmpf_pow_ui(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_random2(arg1: mpf_ptr, arg2: mp_size_t, arg3: mp_exp_t);
}
extern "C" {
    pub fn __gmpf_reldiff(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_set(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_set_d(arg1: mpf_ptr, arg2: f64);
}
extern "C" {
    pub fn __gmpf_set_default_prec(arg1: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_set_prec(arg1: mpf_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_set_prec_raw(arg1: mpf_ptr, arg2: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpf_set_q(arg1: mpf_ptr, arg2: mpq_srcptr);
}
extern "C" {
    pub fn __gmpf_set_si(arg1: mpf_ptr, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn __gmpf_set_str(
        arg1: mpf_ptr,
        arg2: *const ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpf_set_ui(arg1: mpf_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_set_z(arg1: mpf_ptr, arg2: mpz_srcptr);
}
extern "C" {
    pub fn __gmpf_size(arg1: mpf_srcptr) -> usize;
}
extern "C" {
    pub fn __gmpf_sqrt(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_sqrt_ui(arg1: mpf_ptr, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_sub(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_sub_ui(arg1: mpf_ptr, arg2: mpf_srcptr, arg3: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __gmpf_swap(arg1: mpf_ptr, arg2: mpf_ptr);
}
extern "C" {
    pub fn __gmpf_trunc(arg1: mpf_ptr, arg2: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_ui_div(arg1: mpf_ptr, arg2: ::std::os::raw::c_ulong, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_ui_sub(arg1: mpf_ptr, arg2: ::std::os::raw::c_ulong, arg3: mpf_srcptr);
}
extern "C" {
    pub fn __gmpf_urandomb(arg1: mpf_ptr, arg2: gmp_randstate_ptr, arg3: mp_bitcnt_t);
}
extern "C" {
    pub fn __gmpn_add_n(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_srcptr,
        arg4: mp_size_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_addmul_1(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_divexact_1(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t, arg4: mp_limb_t);
}
extern "C" {
    pub fn __gmpn_divexact_by3c(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_divrem(
        arg1: mp_ptr,
        arg2: mp_size_t,
        arg3: mp_ptr,
        arg4: mp_size_t,
        arg5: mp_srcptr,
        arg6: mp_size_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_divrem_1(
        arg1: mp_ptr,
        arg2: mp_size_t,
        arg3: mp_srcptr,
        arg4: mp_size_t,
        arg5: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_divrem_2(
        arg1: mp_ptr,
        arg2: mp_size_t,
        arg3: mp_ptr,
        arg4: mp_size_t,
        arg5: mp_srcptr,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_div_qr_1(
        arg1: mp_ptr,
        arg2: *mut mp_limb_t,
        arg3: mp_srcptr,
        arg4: mp_size_t,
        arg5: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_div_qr_2(
        arg1: mp_ptr,
        arg2: mp_ptr,
        arg3: mp_srcptr,
        arg4: mp_size_t,
        arg5: mp_srcptr,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_gcd(
        arg1: mp_ptr,
        arg2: mp_ptr,
        arg3: mp_size_t,
        arg4: mp_ptr,
        arg5: mp_size_t,
    ) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_gcd_11(arg1: mp_limb_t, arg2: mp_limb_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_gcd_1(arg1: mp_srcptr, arg2: mp_size_t, arg3: mp_limb_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_gcdext_1(
        arg1: *mut mp_limb_signed_t,
        arg2: *mut mp_limb_signed_t,
        arg3: mp_limb_t,
        arg4: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_gcdext(
        arg1: mp_ptr,
        arg2: mp_ptr,
        arg3: *mut mp_size_t,
        arg4: mp_ptr,
        arg5: mp_size_t,
        arg6: mp_ptr,
        arg7: mp_size_t,
    ) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_get_str(
        arg1: *mut ::std::os::raw::c_uchar,
        arg2: ::std::os::raw::c_int,
        arg3: mp_ptr,
        arg4: mp_size_t,
    ) -> usize;
}
extern "C" {
    pub fn __gmpn_hamdist(arg1: mp_srcptr, arg2: mp_srcptr, arg3: mp_size_t) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpn_lshift(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: ::std::os::raw::c_uint,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_mod_1(arg1: mp_srcptr, arg2: mp_size_t, arg3: mp_limb_t) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_mul(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_srcptr,
        arg5: mp_size_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_mul_1(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_mul_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_sqr(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t);
}
extern "C" {
    pub fn __gmpn_com(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t);
}
extern "C" {
    pub fn __gmpn_perfect_square_p(arg1: mp_srcptr, arg2: mp_size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpn_perfect_power_p(arg1: mp_srcptr, arg2: mp_size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpn_popcount(arg1: mp_srcptr, arg2: mp_size_t) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpn_pow_1(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_limb_t,
        arg5: mp_ptr,
    ) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_preinv_mod_1(
        arg1: mp_srcptr,
        arg2: mp_size_t,
        arg3: mp_limb_t,
        arg4: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_random(arg1: mp_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpn_random2(arg1: mp_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpn_rshift(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: ::std::os::raw::c_uint,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_scan0(arg1: mp_srcptr, arg2: mp_bitcnt_t) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpn_scan1(arg1: mp_srcptr, arg2: mp_bitcnt_t) -> mp_bitcnt_t;
}
extern "C" {
    pub fn __gmpn_set_str(
        arg1: mp_ptr,
        arg2: *const ::std::os::raw::c_uchar,
        arg3: usize,
        arg4: ::std::os::raw::c_int,
    ) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sizeinbase(
        arg1: mp_srcptr,
        arg2: mp_size_t,
        arg3: ::std::os::raw::c_int,
    ) -> usize;
}
extern "C" {
    pub fn __gmpn_sqrtrem(
        arg1: mp_ptr,
        arg2: mp_ptr,
        arg3: mp_srcptr,
        arg4: mp_size_t,
    ) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sub_n(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_srcptr,
        arg4: mp_size_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_submul_1(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_limb_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_tdiv_qr(
        arg1: mp_ptr,
        arg2: mp_ptr,
        arg3: mp_size_t,
        arg4: mp_srcptr,
        arg5: mp_size_t,
        arg6: mp_srcptr,
        arg7: mp_size_t,
    );
}
extern "C" {
    pub fn __gmpn_and_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_andn_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_nand_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_ior_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_iorn_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_nior_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_xor_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_xnor_n(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_srcptr, arg4: mp_size_t);
}
extern "C" {
    pub fn __gmpn_copyi(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t);
}
extern "C" {
    pub fn __gmpn_copyd(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t);
}
extern "C" {
    pub fn __gmpn_zero(arg1: mp_ptr, arg2: mp_size_t);
}
extern "C" {
    pub fn __gmpn_cnd_add_n(
        arg1: mp_limb_t,
        arg2: mp_ptr,
        arg3: mp_srcptr,
        arg4: mp_srcptr,
        arg5: mp_size_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_cnd_sub_n(
        arg1: mp_limb_t,
        arg2: mp_ptr,
        arg3: mp_srcptr,
        arg4: mp_srcptr,
        arg5: mp_size_t,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_sec_add_1(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_limb_t,
        arg5: mp_ptr,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_sec_add_1_itch(arg1: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_sub_1(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_limb_t,
        arg5: mp_ptr,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_sec_sub_1_itch(arg1: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_cnd_swap(
        arg1: mp_limb_t,
        arg2: *mut mp_limb_t,
        arg3: *mut mp_limb_t,
        arg4: mp_size_t,
    );
}
extern "C" {
    pub fn __gmpn_sec_mul(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_srcptr,
        arg5: mp_size_t,
        arg6: mp_ptr,
    );
}
extern "C" {
    pub fn __gmpn_sec_mul_itch(arg1: mp_size_t, arg2: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_sqr(arg1: mp_ptr, arg2: mp_srcptr, arg3: mp_size_t, arg4: mp_ptr);
}
extern "C" {
    pub fn __gmpn_sec_sqr_itch(arg1: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_powm(
        arg1: mp_ptr,
        arg2: mp_srcptr,
        arg3: mp_size_t,
        arg4: mp_srcptr,
        arg5: mp_bitcnt_t,
        arg6: mp_srcptr,
        arg7: mp_size_t,
        arg8: mp_ptr,
    );
}
extern "C" {
    pub fn __gmpn_sec_powm_itch(arg1: mp_size_t, arg2: mp_bitcnt_t, arg3: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_tabselect(
        arg1: *mut mp_limb_t,
        arg2: *const mp_limb_t,
        arg3: mp_size_t,
        arg4: mp_size_t,
        arg5: mp_size_t,
    );
}
extern "C" {
    pub fn __gmpn_sec_div_qr(
        arg1: mp_ptr,
        arg2: mp_ptr,
        arg3: mp_size_t,
        arg4: mp_srcptr,
        arg5: mp_size_t,
        arg6: mp_ptr,
    ) -> mp_limb_t;
}
extern "C" {
    pub fn __gmpn_sec_div_qr_itch(arg1: mp_size_t, arg2: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_div_r(
        arg1: mp_ptr,
        arg2: mp_size_t,
        arg3: mp_srcptr,
        arg4: mp_size_t,
        arg5: mp_ptr,
    );
}
extern "C" {
    pub fn __gmpn_sec_div_r_itch(arg1: mp_size_t, arg2: mp_size_t) -> mp_size_t;
}
extern "C" {
    pub fn __gmpn_sec_invert(
        arg1: mp_ptr,
        arg2: mp_ptr,
        arg3: mp_srcptr,
        arg4: mp_size_t,
        arg5: mp_bitcnt_t,
        arg6: mp_ptr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __gmpn_sec_invert_itch(arg1: mp_size_t) -> mp_size_t;
}
pub const GMP_ERROR_NONE: _bindgen_ty_12 = 0;
pub const GMP_ERROR_UNSUPPORTED_ARGUMENT: _bindgen_ty_12 = 1;
pub const GMP_ERROR_DIVISION_BY_ZERO: _bindgen_ty_12 = 2;
pub const GMP_ERROR_SQRT_OF_NEGATIVE: _bindgen_ty_12 = 4;
pub const GMP_ERROR_INVALID_ARGUMENT: _bindgen_ty_12 = 8;
pub const GMP_ERROR_MPZ_OVERFLOW: _bindgen_ty_12 = 16;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
extern "C" {
    pub fn mpz_vinit(v: *mut mpz_t, size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn mpz_vclear(v: *mut mpz_t, size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn mpq_vinit(v: *mut mpq_t, size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn mpq_vclear(v: *mut mpq_t, size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn mpf_set_2dl(f: *mut __mpf_struct, d: f64, l: ::std::os::raw::c_long);
}
extern "C" {
    pub fn mpf_get_2dl(d: *mut f64, l: *mut ::std::os::raw::c_long, f: *mut __mpf_struct);
}
extern "C" {
    pub fn mpf_size_2(f: *mut __mpf_struct) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mpf_add_si(r: *mut __mpf_struct, f: *mut __mpf_struct, i: ::std::os::raw::c_long);
}
extern "C" {
    pub fn mpf_sub_si(r: *mut __mpf_struct, f: *mut __mpf_struct, i: ::std::os::raw::c_long);
}
extern "C" {
    pub fn mpf_si_sub(r: *mut __mpf_struct, i: ::std::os::raw::c_long, f: *mut __mpf_struct);
}
extern "C" {
    pub fn mpf_mul_si(r: *mut __mpf_struct, f: *mut __mpf_struct, i: ::std::os::raw::c_long);
}
extern "C" {
    pub fn mpf_div_si(r: *mut __mpf_struct, f: *mut __mpf_struct, i: ::std::os::raw::c_long);
}
extern "C" {
    pub fn mpf_pow_si(r: *mut __mpf_struct, f: *mut __mpf_struct, i: ::std::os::raw::c_long);
}
extern "C" {
    pub fn mpf_vinit(v: *mut mpf_t, size: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn mpf_vinit2(v: *mut mpf_t, size: ::std::os::raw::c_ulong, prec: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn mpf_vclear(v: *mut mpf_t, size: ::std::os::raw::c_ulong);
}
#[doc = " @cond PRIVATE"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mpc_struct
{
    pub r: mpf_t,
    pub i: mpf_t,
}
#[test]
fn bindgen_test_layout___mpc_struct()
{
    const UNINIT: ::std::mem::MaybeUninit<__mpc_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mpc_struct>(),
        48usize,
        concat!("Size of: ", stringify!(__mpc_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__mpc_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__mpc_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpc_struct),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__mpc_struct),
            "::",
            stringify!(i)
        )
    );
}
#[doc = " @endcond"]
pub type mpc_t = [__mpc_struct; 1usize];
extern "C" {
    #[doc = "            mpc_t functions                             **"]
    pub fn mpc_init(c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_init2(c: *mut __mpc_struct, prec: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn mpc_clear(c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_set_prec(c: *mut __mpc_struct, prec: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn mpc_get_prec(c: *mut __mpc_struct) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn mpc_set_prec_raw(c: *mut __mpc_struct, prec: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn mpc_set(rc: *mut __mpc_struct, c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_set_ui(
        c: *mut __mpc_struct,
        ir: ::std::os::raw::c_ulong,
        ii: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn mpc_set_si(c: *mut __mpc_struct, ir: ::std::os::raw::c_long, ii: ::std::os::raw::c_long);
}
extern "C" {
    pub fn mpc_set_d(c: *mut __mpc_struct, dr: f64, di: f64);
}
extern "C" {
    pub fn mpc_set_z(c: *mut __mpc_struct, zr: *mut __mpz_struct, zi: *mut __mpz_struct);
}
extern "C" {
    pub fn mpc_set_q(c: *mut __mpc_struct, qr: *mut __mpq_struct, qi: *mut __mpq_struct);
}
extern "C" {
    pub fn mpc_set_f(c: *mut __mpc_struct, fr: *mut __mpf_struct, fi: *mut __mpf_struct);
}
extern "C" {
    pub fn mpc_set_str(
        c: *mut __mpc_struct,
        sr: *mut ::std::os::raw::c_char,
        si: *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mpc_init_set(rc: *mut __mpc_struct, c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_init_set_ui(
        c: *mut __mpc_struct,
        ir: ::std::os::raw::c_ulong,
        ii: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn mpc_init_set_si(
        c: *mut __mpc_struct,
        ir: ::std::os::raw::c_long,
        ii: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn mpc_init_set_d(c: *mut __mpc_struct, dr: f64, di: f64);
}
extern "C" {
    pub fn mpc_init_set_f(c: *mut __mpc_struct, fr: *mut __mpf_struct, fi: *mut __mpf_struct);
}
extern "C" {
    pub fn mpc_init_set_str(
        c: *mut __mpc_struct,
        sr: *mut ::std::os::raw::c_char,
        si: *mut ::std::os::raw::c_char,
        base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mpc_neg(rc: *mut __mpc_struct, c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_smod(f: *mut __mpf_struct, c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_rmod(r: *mut __rdpe_struct, c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_mod(f: *mut __mpf_struct, c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_con(rc: *mut __mpc_struct, c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_inv(rc: *mut __mpc_struct, c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_inv2(rc: *mut __mpc_struct, c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_sqr(rc: *mut __mpc_struct, c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_rot(rc: *mut __mpc_struct, c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_flip(rc: *mut __mpc_struct, c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_add(rc: *mut __mpc_struct, c1: *mut __mpc_struct, c2: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_add_f(rc: *mut __mpc_struct, c: *mut __mpc_struct, f: *mut __mpf_struct);
}
extern "C" {
    pub fn mpc_add_ui(
        rc: *mut __mpc_struct,
        c: *mut __mpc_struct,
        r: ::std::os::raw::c_ulong,
        i: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn mpc_sub(rc: *mut __mpc_struct, c1: *mut __mpc_struct, c2: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_sub_f(rc: *mut __mpc_struct, c: *mut __mpc_struct, f: *mut __mpf_struct);
}
extern "C" {
    pub fn mpc_f_sub(rc: *mut __mpc_struct, f: *mut __mpf_struct, c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_sub_ui(
        rc: *mut __mpc_struct,
        c: *mut __mpc_struct,
        r: ::std::os::raw::c_ulong,
        i: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn mpc_ui_sub(
        rc: *mut __mpc_struct,
        r: ::std::os::raw::c_ulong,
        i: ::std::os::raw::c_ulong,
        c: *mut __mpc_struct,
    );
}
extern "C" {
    pub fn mpc_mul(rc: *mut __mpc_struct, c1: *mut __mpc_struct, c2: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_mul_f(rc: *mut __mpc_struct, c: *mut __mpc_struct, f: *mut __mpf_struct);
}
extern "C" {
    pub fn mpc_mul_ui(rc: *mut __mpc_struct, c: *mut __mpc_struct, i: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn mpc_mul_2exp(rc: *mut __mpc_struct, c: *mut __mpc_struct, i: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn mpc_div(rc: *mut __mpc_struct, c1: *mut __mpc_struct, c2: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_div_f(rc: *mut __mpc_struct, c: *mut __mpc_struct, f: *mut __mpf_struct);
}
extern "C" {
    pub fn mpc_f_div(rc: *mut __mpc_struct, f: *mut __mpf_struct, c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_div_ui(rc: *mut __mpc_struct, c: *mut __mpc_struct, i: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn mpc_ui_div(rc: *mut __mpc_struct, i: ::std::os::raw::c_ulong, c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_div_2exp(rc: *mut __mpc_struct, c: *mut __mpc_struct, i: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn mpc_pow_si(rc: *mut __mpc_struct, c: *mut __mpc_struct, i: ::std::os::raw::c_long);
}
extern "C" {
    pub fn mpc_swap(c1: *mut __mpc_struct, c2: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_smod_eq(c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_mod_eq(c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_rot_eq(c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_flip_eq(c: *mut __mpc_struct);
}
extern "C" {
    pub fn mpc_eq(
        c1: *mut __mpc_struct,
        c2: *mut __mpc_struct,
        i: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mpc_eq_zero(c: *mut __mpc_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mpc_eq_one(c: *mut __mpc_struct) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mpc_out_str_2u(
        f: *mut FILE,
        base: ::std::os::raw::c_int,
        n_digits_r: usize,
        n_digits_i: usize,
        c: *mut __mpc_struct,
    ) -> usize;
}
extern "C" {
    pub fn mpc_out_str_2(
        f: *mut FILE,
        base: ::std::os::raw::c_int,
        n_digits_r: usize,
        n_digits_i: usize,
        c: *mut __mpc_struct,
    ) -> usize;
}
extern "C" {
    pub fn mpc_inp_str_u(c: *mut __mpc_struct, f: *mut FILE, base: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn mpc_inp_str(c: *mut __mpc_struct, f: *mut FILE, base: ::std::os::raw::c_int) -> usize;
}
extern "C" {
    pub fn mpc_vinit(v: *mut mpc_t, size: ::std::os::raw::c_long);
}
extern "C" {
    pub fn mpc_vinit2(v: *mut mpc_t, size: ::std::os::raw::c_long, prec: ::std::os::raw::c_long);
}
extern "C" {
    pub fn mpc_vclear(v: *mut mpc_t, size: ::std::os::raw::c_long);
}
extern "C" {
    #[doc = " @brief Set the Multiprecision value <code>f</code> with the value\n stored in <code>e</code>.\n\n @param f The multiprecision floating point number to set.\n @param e The RDPE value to set in <code>f</code>."]
    pub fn mpf_set_rdpe(f: *mut __mpf_struct, e: *mut __rdpe_struct);
}
extern "C" {
    #[doc = " @brief Get the RDPE version of the Multiprecision value <code>f</code>.\n\n @param e The RDPE where the value of <code>f</code> will be stored.\n @param f The multiprecision floating point number to extract the value from."]
    pub fn mpf_get_rdpe(e: *mut __rdpe_struct, f: *mut __mpf_struct);
}
extern "C" {
    #[doc = " @brief Set the Multiprecision value <code>mc</code> with the value\n stored in <code>c</code>.\n\n @param mc The multiprecision complex number to set.\n @param c The <code>cplx_t</code> value to set in <code>mc</code>."]
    pub fn mpc_set_cplx(mc: *mut __mpc_struct, c: *mut __cplx_struct);
}
extern "C" {
    #[doc = " @brief Get the <code>cplx_t</code> version of the Multiprecision value <code>mc</code>.\n\n @param c The <code>cplx_t</code> where the value of <code>mc</code> will be stored.\n @param mc The multiprecision complex number to extract the value from."]
    pub fn mpc_get_cplx(c: *mut __cplx_struct, mc: *mut __mpc_struct);
}
extern "C" {
    #[doc = " @brief Set the Multiprecision value <code>mc</code> with the value\n stored in <code>c</code>.\n\n @param mc The multiprecision complex number to set.\n @param c The CDPE value to set in <code>mc</code>."]
    pub fn mpc_set_cdpe(mc: *mut __mpc_struct, c: *mut __cdpe_struct);
}
extern "C" {
    #[doc = " @brief Get the CDPE version of the Multiprecision value <code>mc</code>.\n\n @param c The CDPE where the value of <code>mc</code> will be stored.\n @param mc The multiprecision complex number to extract the value from."]
    pub fn mpc_get_cdpe(c: *mut __cdpe_struct, mc: *mut __mpc_struct);
}
#[doc = " @brief The type of a function that evaluates the poynomial (Standard floating point version)."]
pub type mps_polynomial_feval_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        x: *mut __cplx_struct,
        value: *mut __cplx_struct,
        error: *mut f64,
    ) -> mps_boolean,
>;
#[doc = " @brief The type of a function that evaluates the polynomial (CDPE version)."]
pub type mps_polynomial_deval_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        x: *mut __cdpe_struct,
        value: *mut __cdpe_struct,
        error: *mut __rdpe_struct,
    ) -> mps_boolean,
>;
#[doc = " @brief The type of a function that evaluates the polynomial (MP version).\n The computation must be carried out with the precision of the value \\f$x\\f$."]
pub type mps_polynomial_meval_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        x: *mut __mpc_struct,
        value: *mut __mpc_struct,
        error: *mut __rdpe_struct,
    ) -> mps_boolean,
>;
#[doc = " @brief Function that will be used to deallocate the polynomial on context destruction."]
pub type mps_polynomial_free_t =
    ::std::option::Option<unsafe extern "C" fn(ctx: *mut mps_context, p: *mut mps_polynomial)>;
#[doc = " @brief Function that will be used to raise the precision of the coefficients representing\n the polynomial to the working precision wp."]
pub type mps_polynomial_raise_data_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        wp: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long,
>;
#[doc = " @brief Function used to determine useful starting approximation.\n\n This is the floating point implementation."]
pub type mps_polynomial_fstart_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        approximations: *mut *mut mps_approximation,
    ),
>;
#[doc = " @brief Function used to determine useful starting approximation.\n\n This is the CDPE implementation."]
pub type mps_polynomial_dstart_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        approximations: *mut *mut mps_approximation,
    ),
>;
#[doc = " @brief Function used to determine useful starting approximation.\n\n This is the MP implementation."]
pub type mps_polynomial_mstart_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        approximations: *mut *mut mps_approximation,
    ),
>;
#[doc = " @brief Function that computes \\f$\\frac{p}{p'}\\f$ (floating point version)"]
pub type mps_polynomial_fnewton_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        root: *mut mps_approximation,
        x: *mut __cplx_struct,
    ),
>;
#[doc = " @brief Function that computes \\f$\\frac{p}{p'}\\f$ (dpe version)"]
pub type mps_polynomial_dnewton_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        root: *mut mps_approximation,
        corr: *mut __cdpe_struct,
    ),
>;
#[doc = " @brief Function that computes \\f$\\frac{p}{p'}\\f$ (multiprecision version)"]
pub type mps_polynomial_mnewton_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        root: *mut mps_approximation,
        corr: *mut __mpc_struct,
        wp: ::std::os::raw::c_long,
    ),
>;
#[doc = " @brief Function that returns the leading coefficient of the polynomial.\n This defaults to the function that returns one (i.e. the default polynomial\n is monic)."]
pub type mps_polynomial_get_leading_coefficient_t = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut mps_context, p: *mut mps_polynomial, lc: *mut __mpc_struct),
>;
#[doc = " @brief Struct that represents an abstract polynomial. All the other\n real polynomial implementations (such as mps_monomial_poly, mps_secular_equation, ...)\n inherits from this."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_polynomial
{
    #[doc = " @brief Name of the type. This must be a global static string that\n can be used to check if a mps_polynomial is of a specific type.\n It can be NULL to leave the type vague."]
    pub type_name: *const ::std::os::raw::c_char,
    #[doc = " @brief The degree of the polynomial."]
    pub degree: ::std::os::raw::c_int,
    #[doc = " @brief Bits of precision of the coefficients.\n\n The precision used in computation can be adjusted with a call to mps_polynomial_raise_data()\n but can never be higher than the input precision."]
    pub prec: ::std::os::raw::c_long,
    #[doc = " @brief Structure of the polynomial, i.e., the algebraic\n (or non-algebraic) structure where the coefficients\n are found."]
    pub structure: mps_structure,
    #[doc = " @brief Density of the coefficients, or MPS_DENSITY_USER\n if the coefficients (or the newton fraction) is provided\n via a user routine"]
    pub density: mps_density,
    #[doc = " @brief This is true if the polynomial has thread-safe methods. Note that\n this is the default assumption set by mps_polynomial_init(). You should\n overwrite after calling it if that's not the case."]
    pub thread_safe: mps_boolean,
    #[doc = " @brief Method that evaluates the polynomial."]
    pub feval: mps_polynomial_feval_t,
    #[doc = " @brief Method that evaluates the polynomial."]
    pub deval: mps_polynomial_deval_t,
    #[doc = " @brief Method that evaluates the polynomial."]
    pub meval: mps_polynomial_meval_t,
    #[doc = " @brief Method that collocate initial starting points."]
    pub fstart: mps_polynomial_fstart_t,
    #[doc = " @brief Method that collocate initial starting points."]
    pub dstart: mps_polynomial_dstart_t,
    #[doc = " @brief Method that collocate initial starting points."]
    pub mstart: mps_polynomial_mstart_t,
    #[doc = " @brief Function used to release polynomial resources."]
    pub free: mps_polynomial_free_t,
    #[doc = " @brief Function used to raise precision of the coefficients\n of the representation of the polynomial."]
    pub raise_data: mps_polynomial_raise_data_t,
    #[doc = " @brief Function used to compute the Newton correction in a point."]
    pub fnewton: mps_polynomial_fnewton_t,
    #[doc = " @brief Function used to compute the Newton correction in a point."]
    pub dnewton: mps_polynomial_dnewton_t,
    #[doc = " @brief Function used to compute the Newton correction in a point."]
    pub mnewton: mps_polynomial_mnewton_t,
    #[doc = " @brief Function used to retrieve the leading coefficient of the\n polynomial."]
    pub get_leading_coefficient: mps_polynomial_get_leading_coefficient_t,
}
#[test]
fn bindgen_test_layout_mps_polynomial()
{
    const UNINIT: ::std::mem::MaybeUninit<mps_polynomial> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mps_polynomial>(),
        136usize,
        concat!("Size of: ", stringify!(mps_polynomial))
    );
    assert_eq!(
        ::std::mem::align_of::<mps_polynomial>(),
        8usize,
        concat!("Alignment of ", stringify!(mps_polynomial))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(type_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).degree) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(degree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prec) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(prec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).structure) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(structure)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).density) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(density)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thread_safe) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(thread_safe)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).feval) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(feval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deval) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(deval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meval) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(meval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fstart) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(fstart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dstart) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(dstart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mstart) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(mstart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).raise_data) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(raise_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fnewton) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(fnewton)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dnewton) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(dnewton)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mnewton) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(mnewton)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_leading_coefficient) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_polynomial),
            "::",
            stringify!(get_leading_coefficient)
        )
    );
}
extern "C" {
    pub fn mps_polynomial_init(ctx: *mut mps_context, p: *mut mps_polynomial);
}
extern "C" {
    pub fn mps_polynomial_new(ctx: *mut mps_context) -> *mut mps_polynomial;
}
extern "C" {
    pub fn mps_polynomial_check_type(
        p: *mut mps_polynomial,
        type_name: *const ::std::os::raw::c_char,
    ) -> mps_boolean;
}
extern "C" {
    pub fn mps_polynomial_cast(
        type_name: *const ::std::os::raw::c_char,
        p: *mut mps_polynomial,
    ) -> *mut mps_polynomial;
}
extern "C" {
    pub fn mps_polynomial_feval(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        x: *mut __cplx_struct,
        value: *mut __cplx_struct,
        error: *mut f64,
    ) -> mps_boolean;
}
extern "C" {
    pub fn mps_polynomial_deval(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        x: *mut __cdpe_struct,
        value: *mut __cdpe_struct,
        error: *mut __rdpe_struct,
    ) -> mps_boolean;
}
extern "C" {
    pub fn mps_polynomial_meval(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        x: *mut __mpc_struct,
        value: *mut __mpc_struct,
        error: *mut __rdpe_struct,
    ) -> mps_boolean;
}
extern "C" {
    pub fn mps_polynomial_fstart(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        approximations: *mut *mut mps_approximation,
    );
}
extern "C" {
    pub fn mps_polynomial_dstart(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        approximations: *mut *mut mps_approximation,
    );
}
extern "C" {
    pub fn mps_polynomial_mstart(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        approximations: *mut *mut mps_approximation,
    );
}
extern "C" {
    pub fn mps_polynomial_free(ctx: *mut mps_context, p: *mut mps_polynomial);
}
extern "C" {
    pub fn mps_polynomial_fnewton(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        root: *mut mps_approximation,
        corr: *mut __cplx_struct,
    );
}
extern "C" {
    pub fn mps_polynomial_dnewton(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        root: *mut mps_approximation,
        corr: *mut __cdpe_struct,
    );
}
extern "C" {
    pub fn mps_polynomial_mnewton(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        root: *mut mps_approximation,
        corr: *mut __mpc_struct,
        wp: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn mps_polynomial_get_leading_coefficient(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        lc: *mut __mpc_struct,
    );
}
extern "C" {
    pub fn mps_polynomial_raise_data(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        wp: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mps_polynomial_set_input_prec(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        prec: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn mps_general_fstart(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        approximations: *mut *mut mps_approximation,
    );
}
extern "C" {
    pub fn mps_general_dstart(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        approximations: *mut *mut mps_approximation,
    );
}
extern "C" {
    pub fn mps_general_mstart(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        approximations: *mut *mut mps_approximation,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mps_chebyshev_poly
{
    #[doc = " @brief Base implementation of a polynomial."]
    pub super_: mps_polynomial,
    #[doc = " @brief Floating point coefficients of the polynomial in the Chebyshev\n base"]
    pub fpc: *mut cplx_t,
    #[doc = " @brief DPE floating point coefficients of the polynomial in the Chebyshev\n base."]
    pub dpc: *mut cdpe_t,
    #[doc = " @brief Multiprecision complex coefficients of the polynomial in the Chebyshev\n base."]
    pub mfpc: *mut mpc_t,
    #[doc = " @brief Rational coefficients of the polynomial. These are the real parts of the\n coefficients."]
    pub rational_real_coeffs: *mut mpq_t,
    #[doc = " @brief Ratinonal coefficients of the polynomial. These are the imaginary parts\n of the coefficients."]
    pub rational_imag_coeffs: *mut mpq_t,
    #[doc = " @brief Leading coefficient of the polynomial."]
    pub lc: mpc_t,
    #[doc = " @brief Internal mutex used to manage the change of precision."]
    pub precision_mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_mps_chebyshev_poly()
{
    const UNINIT: ::std::mem::MaybeUninit<mps_chebyshev_poly> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mps_chebyshev_poly>(),
        264usize,
        concat!("Size of: ", stringify!(mps_chebyshev_poly))
    );
    assert_eq!(
        ::std::mem::align_of::<mps_chebyshev_poly>(),
        8usize,
        concat!("Alignment of ", stringify!(mps_chebyshev_poly))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).super_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_chebyshev_poly),
            "::",
            stringify!(super_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fpc) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_chebyshev_poly),
            "::",
            stringify!(fpc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dpc) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_chebyshev_poly),
            "::",
            stringify!(dpc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mfpc) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_chebyshev_poly),
            "::",
            stringify!(mfpc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rational_real_coeffs) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_chebyshev_poly),
            "::",
            stringify!(rational_real_coeffs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rational_imag_coeffs) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_chebyshev_poly),
            "::",
            stringify!(rational_imag_coeffs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lc) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_chebyshev_poly),
            "::",
            stringify!(lc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).precision_mutex) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_chebyshev_poly),
            "::",
            stringify!(precision_mutex)
        )
    );
}
extern "C" {
    #[doc = " @brief Create a new polynomial represented in the Chebyshev base with\n degree set to n."]
    pub fn mps_chebyshev_poly_new(
        ctx: *mut mps_context,
        n: ::std::os::raw::c_int,
        structure: mps_structure,
    ) -> *mut mps_chebyshev_poly;
}
extern "C" {
    #[doc = " @brief Set the coefficient relative to the i-th element of the Chebyshev\n base.\n\n This function takes a rational number as input, and is usable only if the\n Chebyshev polynomial is represented using rational coefficients."]
    pub fn mps_chebyshev_poly_set_coefficient_q(
        ctx: *mut mps_context,
        poly: *mut mps_chebyshev_poly,
        i: ::std::os::raw::c_int,
        real_part: *mut __mpq_struct,
        imag_part: *mut __mpq_struct,
    );
}
extern "C" {
    #[doc = " @brief Set the coefficient relative to the i-th element of the Chebyshev\n base.\n\n This function takes a multiprecision floating point number as input."]
    pub fn mps_chebyshev_poly_set_coefficient_f(
        ctx: *mut mps_context,
        poly: *mut mps_chebyshev_poly,
        i: ::std::os::raw::c_int,
        coeff: *mut __mpc_struct,
    );
}
extern "C" {
    #[doc = " @brief Set the coefficient of the i-th element of the Chebyshev base.\n\n This function takes an integer value as input.\n\n @param ctx The current mps_context\n @param poly The Chebyshev polynomial whose coefficient should be set.\n @param i The degree of the coefficient to set.\n @param real_coeff The real part of the new coefficient.\n @param imag_coeff The imaginary part of the new coefficient."]
    pub fn mps_chebyshev_poly_set_coefficient_i(
        ctx: *mut mps_context,
        poly: *mut mps_chebyshev_poly,
        i: ::std::os::raw::c_int,
        real_coeff: ::std::os::raw::c_long,
        imag_coeff: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn mps_chebyshev_poly_read_from_stream(
        ctx: *mut mps_context,
        buffer: *mut mps_input_buffer,
        structure: mps_structure,
        density: mps_density,
        precision: ::std::os::raw::c_long,
    ) -> *mut mps_chebyshev_poly;
}
extern "C" {
    #[doc = " @brief Create a new matrix polynomial of the given degree.\n\n @param ctx The current mps_context.\n @param degree The degree of the matrix polynomial.\n @param m The size of the matrices that compose the matrix polynomial.\n @param monic A boolean value that, if set to true, specify that the leading\n              coefficient of the polynomial is the identity matrix, and so\n              should not specified explicitely.\n @return A pointer to a newly allocated mps_monomial_matrix_poly that should\n be subsequently free with a call to mps_monomial_matrix_poly_free()."]
    pub fn mps_monomial_matrix_poly_new(
        ctx: *mut mps_context,
        degree: ::std::os::raw::c_int,
        m: ::std::os::raw::c_int,
        monic: mps_boolean,
    ) -> *mut mps_monomial_matrix_poly;
}
extern "C" {
    #[doc = " @brief Free a matrix polynomial.\n\n @param ctx The current mps_context.\n @param poly The mps_monomial_matrix_poly that should be freed, casted to\n             a mps_polynomial* pointer."]
    pub fn mps_monomial_matrix_poly_free(ctx: *mut mps_context, poly: *mut mps_polynomial);
}
extern "C" {
    #[doc = " @brief Add some flags (some properties) to this matrix polynomial.\n\n @param ctx The current mps_context\n @param mpoly The matrix polynomial.\n @param flag The flags to add."]
    pub fn mps_monomial_matrix_poly_add_flags(
        ctx: *mut mps_context,
        mpoly: *mut mps_monomial_matrix_poly,
        flag: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Clear some flags (properties) of this matrix polynomial.\n\n @param ctx The current mps_context\n @param mpoly The matrix polynomial.\n @param flag The flags to clear."]
    pub fn mps_monomial_matrix_poly_clear_flags(
        ctx: *mut mps_context,
        mpoly: *mut mps_monomial_matrix_poly,
        flag: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " @brief Set the coefficient of degree i of the matrix polynomial.\n\n @param ctx The current mps_context\n @param mpoly The mps_monomial_matrix_poly where the coefficients should be\n set.\n @param i The degree of the coeffient to set.\n @param matrix A pointer to the first element of the matrix stored in row-major order."]
    pub fn mps_monomial_matrix_poly_set_coefficient_d(
        ctx: *mut mps_context,
        mpoly: *mut mps_monomial_matrix_poly,
        i: ::std::os::raw::c_int,
        matrix: *mut cplx_t,
    );
}
extern "C" {
    #[doc = " @brief Set the coefficient of degree i of the matrix polynomial.\n\n @param ctx The current mps_context\n @param mpoly The mps_monomial_matrix_poly where the coefficients should be\n set.\n @param i The degree of the coeffient to set.\n @param matrix_r A pointer to the first element of the matrix of the real parts\n of the coefficients, stored in row-major order\n @param matrix_i A pointer to the first element of the matrix of the imaginary parts\n of the coefficients, stored in row-major order"]
    pub fn mps_monomial_matrix_poly_set_coefficient_q(
        ctx: *mut mps_context,
        mpoly: *mut mps_monomial_matrix_poly,
        i: ::std::os::raw::c_int,
        matrix_r: *mut mpq_t,
        matrix_i: *mut mpq_t,
    );
}
extern "C" {
    #[doc = " @brief Evaluate a matrix polynomial at a point, in the sense of\n evaluating \\f$det(P(x))\\f$.\n\n @param ctx The current mps_context\n @param poly The matrix polynomial to evaluate\n @param x The point in which the evaluation is requested\n @param value The value of \\f$det(P(x))\\f$\n @param error An upper bound to the absolute error that affects the result.\n @return true if the evaluation was successful."]
    pub fn mps_monomial_matrix_poly_meval(
        ctx: *mut mps_context,
        poly: *mut mps_polynomial,
        x: *mut __mpc_struct,
        value: *mut __mpc_struct,
        error: *mut __rdpe_struct,
    ) -> mps_boolean;
}
extern "C" {
    #[doc = " @brief Raise the working precision of this monomial matrix polynomal\n to the required numnber of bits.\n\n @param ctx The current mps_context.\n @param p The polynomial whose working precision should be set.\n @param wp The bits of desired working precision.\n @return The precision set in the polynomial. Note that this value\n may be higher than wp due to the fact that, in general, not all\n the precisions are available on the system and the first higher precision\n of the value required will be used."]
    pub fn mps_monomial_matrix_poly_raise_data(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        wp: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mps_monomial_poly_new(
        s: *mut mps_context,
        degree: ::std::os::raw::c_long,
    ) -> *mut mps_monomial_poly;
}
extern "C" {
    pub fn mps_monomial_poly_free(s: *mut mps_context, mp: *mut mps_polynomial);
}
extern "C" {
    pub fn mps_monomial_poly_get_precision(
        s: *mut mps_context,
        mp: *mut mps_monomial_poly,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mps_monomial_poly_raise_precision(
        s: *mut mps_context,
        mp: *mut mps_polynomial,
        prec: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mps_monomial_poly_set_coefficient_q(
        s: *mut mps_context,
        mp: *mut mps_monomial_poly,
        i: ::std::os::raw::c_long,
        real_part: *mut __mpq_struct,
        imag_part: *mut __mpq_struct,
    );
}
extern "C" {
    pub fn mps_monomial_poly_set_coefficient_d(
        s: *mut mps_context,
        mp: *mut mps_monomial_poly,
        i: ::std::os::raw::c_long,
        real_part: f64,
        imag_part: f64,
    );
}
extern "C" {
    pub fn mps_monomial_poly_set_coefficient_f(
        s: *mut mps_context,
        p: *mut mps_monomial_poly,
        i: ::std::os::raw::c_long,
        coeff: *mut __mpc_struct,
    );
}
extern "C" {
    pub fn mps_monomial_poly_set_coefficient_int(
        s: *mut mps_context,
        mp: *mut mps_monomial_poly,
        i: ::std::os::raw::c_long,
        real_part: ::std::os::raw::c_longlong,
        imag_part: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    pub fn mps_monomial_poly_set_coefficient_s(
        s: *mut mps_context,
        p: *mut mps_monomial_poly,
        i: ::std::os::raw::c_int,
        real_coeff: *const ::std::os::raw::c_char,
        imag_coeff: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn mps_monomial_poly_get_coefficient_d(
        s: *mut mps_context,
        p: *mut mps_monomial_poly,
        i: ::std::os::raw::c_int,
        output: *mut __cplx_struct,
    );
}
extern "C" {
    pub fn mps_monomial_poly_get_coefficient_q(
        s: *mut mps_context,
        p: *mut mps_monomial_poly,
        i: ::std::os::raw::c_int,
        real_output: *mut __mpq_struct,
        imag_output: *mut __mpq_struct,
    );
}
extern "C" {
    pub fn mps_monomial_poly_derive(
        s: *mut mps_context,
        p: *mut mps_monomial_poly,
        k: ::std::os::raw::c_int,
        wp: ::std::os::raw::c_long,
    ) -> *mut mps_monomial_poly;
}
extern "C" {
    pub fn mps_monomial_poly_feval(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        x: *mut __cplx_struct,
        value: *mut __cplx_struct,
        error: *mut f64,
    ) -> mps_boolean;
}
extern "C" {
    pub fn mps_monomial_poly_deval(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        x: *mut __cdpe_struct,
        value: *mut __cdpe_struct,
        error: *mut __rdpe_struct,
    ) -> mps_boolean;
}
extern "C" {
    pub fn mps_monomial_poly_meval(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        x: *mut __mpc_struct,
        value: *mut __mpc_struct,
        error: *mut __rdpe_struct,
    ) -> mps_boolean;
}
extern "C" {
    pub fn mps_monomial_poly_fstart(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        approximations: *mut *mut mps_approximation,
    );
}
extern "C" {
    pub fn mps_monomial_poly_dstart(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        approximations: *mut *mut mps_approximation,
    );
}
extern "C" {
    pub fn mps_monomial_poly_mstart(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        approximations: *mut *mut mps_approximation,
    );
}
extern "C" {
    pub fn mps_monomial_poly_fnewton(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        root: *mut mps_approximation,
        corr: *mut __cplx_struct,
    );
}
extern "C" {
    pub fn mps_monomial_poly_dnewton(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        root: *mut mps_approximation,
        corr: *mut __cdpe_struct,
    );
}
extern "C" {
    pub fn mps_monomial_poly_mnewton(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        root: *mut mps_approximation,
        corr: *mut __mpc_struct,
        wp: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn mps_monomial_poly_get_leading_coefficient(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        leading_coefficient: *mut __mpc_struct,
    );
}
extern "C" {
    pub fn mps_monomial_poly_deflate(ctx: *mut mps_context, p: *mut mps_polynomial);
}
extern "C" {
    pub fn mps_monomial_poly_read_from_stream(
        s: *mut mps_context,
        buffer: *mut mps_input_buffer,
        structure: mps_structure,
        density: mps_density,
        precision: ::std::os::raw::c_long,
    ) -> *mut mps_monomial_poly;
}
extern "C" {
    pub fn mps_secular_fnewton(
        st: *mut mps_context,
        p: *mut mps_polynomial,
        root: *mut mps_approximation,
        corr: *mut __cplx_struct,
    );
}
extern "C" {
    pub fn mps_secular_dnewton(
        st: *mut mps_context,
        p: *mut mps_polynomial,
        root: *mut mps_approximation,
        corr: *mut __cdpe_struct,
    );
}
extern "C" {
    pub fn mps_secular_mnewton(
        st: *mut mps_context,
        p: *mut mps_polynomial,
        root: *mut mps_approximation,
        corr: *mut __mpc_struct,
        wp: ::std::os::raw::c_long,
    );
}
extern "C" {
    pub fn mps_secular_ga_regenerate_coefficients(s: *mut mps_context) -> mps_boolean;
}
extern "C" {
    pub fn mps_secular_deflate(s: *mut mps_context, sec: *mut mps_secular_equation);
}
extern "C" {
    pub fn mps_secular_check_data(s: *mut mps_context, which_case: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn mps_secular_restart(s: *mut mps_context);
}
extern "C" {
    pub fn mps_secular_switch_phase(s: *mut mps_context, phase: mps_phase);
}
extern "C" {
    pub fn mps_secular_raise_coefficient_precision(
        s: *mut mps_context,
        p: *mut mps_polynomial,
        wp: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mps_secular_raise_precision(s: *mut mps_context, wp: ::std::os::raw::c_int);
}
extern "C" {
    pub fn mps_secular_raise_root_precision(s: *mut mps_context, wp: ::std::os::raw::c_int);
}
extern "C" {
    pub fn mps_secular_fstart(
        s: *mut mps_context,
        sec: *mut mps_secular_equation,
        approximations: *mut *mut mps_approximation,
    );
}
extern "C" {
    pub fn mps_secular_dstart(
        s: *mut mps_context,
        sec: *mut mps_secular_equation,
        approximations: *mut *mut mps_approximation,
    );
}
extern "C" {
    pub fn mps_secular_mstart(
        s: *mut mps_context,
        sec: *mut mps_secular_equation,
        approximations: *mut *mut mps_approximation,
    );
}
extern "C" {
    pub fn mps_secular_ga_fiterate(
        s: *mut mps_context,
        maxit: ::std::os::raw::c_int,
        just_regenerated: mps_boolean,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mps_secular_ga_diterate(
        s: *mut mps_context,
        maxit: ::std::os::raw::c_int,
        just_regenerated: mps_boolean,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mps_secular_ga_miterate(
        s: *mut mps_context,
        maxit: ::std::os::raw::c_int,
        just_regenerated: mps_boolean,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mps_secular_ga_check_stop(s: *mut mps_context) -> mps_boolean;
}
extern "C" {
    pub fn mps_secular_ga_update_coefficients(s: *mut mps_context);
}
extern "C" {
    pub fn mps_secular_equation_new(
        s: *mut mps_context,
        afpc: *mut cplx_t,
        bfpc: *mut cplx_t,
        n: ::std::os::raw::c_ulong,
    ) -> *mut mps_secular_equation;
}
extern "C" {
    pub fn mps_secular_equation_new_raw(
        s: *mut mps_context,
        n: ::std::os::raw::c_ulong,
    ) -> *mut mps_secular_equation;
}
extern "C" {
    pub fn mps_secular_equation_set_coefficient_f(
        ctx: *mut mps_context,
        p: *mut mps_secular_equation,
        i: ::std::os::raw::c_int,
        a: *mut __mpc_struct,
        b: *mut __mpc_struct,
    );
}
extern "C" {
    pub fn mps_secular_equation_set_coefficient_q(
        ctx: *mut mps_context,
        p: *mut mps_secular_equation,
        i: ::std::os::raw::c_int,
        ar: *mut __mpq_struct,
        ai: *mut __mpq_struct,
        br: *mut __mpq_struct,
        bi: *mut __mpq_struct,
    );
}
extern "C" {
    pub fn mps_secular_equation_free(ctx: *mut mps_context, p: *mut mps_polynomial);
}
extern "C" {
    pub fn mps_secular_set_radii(s: *mut mps_context);
}
extern "C" {
    pub fn mps_secular_poly_feval_with_error(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        x: *mut __cplx_struct,
        value: *mut __cplx_struct,
        error: *mut f64,
    ) -> mps_boolean;
}
extern "C" {
    pub fn mps_secular_poly_deval_with_error(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        x: *mut __cdpe_struct,
        value: *mut __cdpe_struct,
        error: *mut __rdpe_struct,
    ) -> mps_boolean;
}
extern "C" {
    pub fn mps_secular_poly_meval_with_error(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        x: *mut __mpc_struct,
        value: *mut __mpc_struct,
        error: *mut __rdpe_struct,
    ) -> mps_boolean;
}
extern "C" {
    pub fn mps_secular_poly_fstart(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        approximations: *mut *mut mps_approximation,
    );
}
extern "C" {
    pub fn mps_secular_poly_dstart(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        approximations: *mut *mut mps_approximation,
    );
}
extern "C" {
    pub fn mps_secular_poly_mstart(
        ctx: *mut mps_context,
        p: *mut mps_polynomial,
        approximations: *mut *mut mps_approximation,
    );
}
extern "C" {
    pub fn mps_secular_equation_read_from_stream(
        ctx: *mut mps_context,
        buffer: *mut mps_input_buffer,
        structure: mps_structure,
        density: mps_density,
        precision: ::std::os::raw::c_long,
    ) -> *mut mps_secular_equation;
}
#[doc = " @brief This type represent an abstract implementation of a driver for the\n regeneration step of the main algorithm.\n\n A standard implementation is given for polynomals internally in the MPSolve\n code but a custom implementation may be given by the user by calling\n mps_context_set_regeneration_driver()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mps_regeneration_driver
{
    pub update_fsecular_equation: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut mps_context,
            p: *mut mps_polynomial,
            approximations: *mut *mut mps_approximation,
            old: *mut mps_secular_equation,
        ) -> mps_boolean,
    >,
    pub update_dsecular_equation: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut mps_context,
            p: *mut mps_polynomial,
            approximations: *mut *mut mps_approximation,
            old: *mut mps_secular_equation,
        ) -> mps_boolean,
    >,
    pub update_msecular_equation: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut mps_context,
            p: *mut mps_polynomial,
            approximations: *mut *mut mps_approximation,
            old: *mut mps_secular_equation,
        ) -> mps_boolean,
    >,
    #[doc = " @brief Optional function that is called by the mps_regeneration_driver_free()\n method. It is intended for custom regeneration driver that needs to free\n additional data before having the function destroyed."]
    pub free: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut mps_context, rd: *mut mps_regeneration_driver),
    >,
}
#[test]
fn bindgen_test_layout_mps_regeneration_driver()
{
    const UNINIT: ::std::mem::MaybeUninit<mps_regeneration_driver> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mps_regeneration_driver>(),
        32usize,
        concat!("Size of: ", stringify!(mps_regeneration_driver))
    );
    assert_eq!(
        ::std::mem::align_of::<mps_regeneration_driver>(),
        8usize,
        concat!("Alignment of ", stringify!(mps_regeneration_driver))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_fsecular_equation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_regeneration_driver),
            "::",
            stringify!(update_fsecular_equation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_dsecular_equation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_regeneration_driver),
            "::",
            stringify!(update_dsecular_equation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_msecular_equation) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_regeneration_driver),
            "::",
            stringify!(update_msecular_equation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mps_regeneration_driver),
            "::",
            stringify!(free)
        )
    );
}
extern "C" {
    pub fn mps_regeneration_driver_new_standard(
        ctx: *mut mps_context,
    ) -> *mut mps_regeneration_driver;
}
extern "C" {
    pub fn mps_regeneration_driver_free(ctx: *mut mps_context, rd: *mut mps_regeneration_driver);
}
extern "C" {
    pub fn mps_approximation_new(s: *mut mps_context) -> *mut mps_approximation;
}
extern "C" {
    pub fn mps_approximation_free(s: *mut mps_context, appr: *mut mps_approximation);
}
extern "C" {
    pub fn mps_approximation_copy(
        ctx: *mut mps_context,
        original: *mut mps_approximation,
    ) -> *mut mps_approximation;
}
extern "C" {
    pub fn mps_approximation_get_fvalue(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
        output: *mut __cplx_struct,
    );
}
extern "C" {
    pub fn mps_approximation_get_dvalue(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
        output: *mut __cdpe_struct,
    );
}
extern "C" {
    pub fn mps_approximation_get_mvalue(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
        output: *mut __mpc_struct,
    );
}
extern "C" {
    pub fn mps_approximation_get_frad(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
    ) -> f64;
}
extern "C" {
    pub fn mps_approximation_get_drad(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
        output: *mut __rdpe_struct,
    );
}
extern "C" {
    pub fn mps_approximation_get_status(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
    ) -> mps_root_status;
}
extern "C" {
    pub fn mps_approximation_get_attrs(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
    ) -> mps_root_attrs;
}
extern "C" {
    pub fn mps_approximaiton_get_inclusion(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
    ) -> mps_root_inclusion;
}
extern "C" {
    pub fn mps_approximation_get_again(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
    ) -> mps_boolean;
}
extern "C" {
    pub fn mps_approximation_set_fvalue(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
        value: *mut __cplx_struct,
    );
}
extern "C" {
    pub fn mps_approximation_set_dvalue(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
        value: *mut __cdpe_struct,
    );
}
extern "C" {
    pub fn mps_approximation_set_mvalue(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
        value: *mut __mpc_struct,
    );
}
extern "C" {
    pub fn mps_approximation_set_frad(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
        frad: f64,
    );
}
extern "C" {
    pub fn mps_approximation_set_drad(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
        drad: *mut __rdpe_struct,
    );
}
extern "C" {
    pub fn mps_approximation_set_status(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
        status: mps_root_status,
    );
}
extern "C" {
    pub fn mps_approximation_set_attrs(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
        attrs: mps_root_attrs,
    );
}
extern "C" {
    pub fn mps_approximation_set_inclusion(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
        inclusion: mps_root_inclusion,
    );
}
extern "C" {
    pub fn mps_approximation_set_again(
        ctx: *mut mps_context,
        approximation: *mut mps_approximation,
        again: mps_boolean,
    );
}
#[doc = " @brief Routine that performs the computation loop to solve the polynomial\n or the secular equation"]
pub type mps_mpsolve_ptr = ::std::option::Option<unsafe extern "C" fn(status: *mut mps_context)>;
#[doc = " @brief Pointer to the callback for the async version of mpsolve"]
pub type mps_callback = ::std::option::Option<
    unsafe extern "C" fn(
        status: *mut mps_context,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
extern "C" {
    pub fn mps_context_new() -> *mut mps_context;
}
extern "C" {
    pub fn mps_context_free(s: *mut mps_context);
}
extern "C" {
    pub fn mps_context_abort(s: *mut mps_context);
}
extern "C" {
    pub fn mps_context_set_poly_d(
        s: *mut mps_context,
        coeff: *mut cplx_t,
        n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mps_context_set_input_poly(s: *mut mps_context, p: *mut mps_polynomial);
}
extern "C" {
    pub fn mps_context_set_poly_i(
        s: *mut mps_context,
        coeff: *mut ::std::os::raw::c_int,
        n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mps_context_select_algorithm(s: *mut mps_context, algorithm: mps_algorithm);
}
extern "C" {
    pub fn mps_context_set_degree(s: *mut mps_context, n: ::std::os::raw::c_int);
}
extern "C" {
    pub fn mps_context_get_data_prec_max(s: *mut mps_context) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mps_context_get_minimum_precision(s: *mut mps_context) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mps_context_get_degree(s: *mut mps_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mps_context_get_roots_d(
        s: *mut mps_context,
        roots: *mut *mut cplx_t,
        radius: *mut *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mps_context_get_roots_m(
        s: *mut mps_context,
        roots: *mut *mut mpc_t,
        radius: *mut *mut rdpe_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mps_context_get_zero_roots(s: *mut mps_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mps_context_get_root_status(
        ctx: *mut mps_context,
        i: ::std::os::raw::c_int,
    ) -> mps_root_status;
}
extern "C" {
    pub fn mps_context_get_over_max(s: *mut mps_context) -> mps_boolean;
}
extern "C" {
    pub fn mps_context_get_active_poly(ctx: *mut mps_context) -> *mut mps_polynomial;
}
extern "C" {
    pub fn mps_context_get_approximations(ctx: *mut mps_context) -> *mut *mut mps_approximation;
}
extern "C" {
    pub fn mps_context_set_input_prec(s: *mut mps_context, prec: ::std::os::raw::c_long);
}
extern "C" {
    pub fn mps_context_set_output_prec(s: *mut mps_context, prec: ::std::os::raw::c_long);
}
extern "C" {
    pub fn mps_context_set_output_format(s: *mut mps_context, format: mps_output_format);
}
extern "C" {
    pub fn mps_context_set_output_goal(s: *mut mps_context, goal: mps_output_goal);
}
extern "C" {
    pub fn mps_context_set_starting_phase(s: *mut mps_context, phase: mps_phase);
}
extern "C" {
    pub fn mps_context_set_log_stream(s: *mut mps_context, logstr: *mut FILE);
}
extern "C" {
    pub fn mps_context_set_jacobi_iterations(s: *mut mps_context, jacobi_iterations: mps_boolean);
}
extern "C" {
    pub fn mps_context_select_starting_strategy(
        s: *mut mps_context,
        strategy: mps_starting_strategy,
    );
}
extern "C" {
    pub fn mps_context_set_avoid_multiprecision(
        s: *mut mps_context,
        avoid_multiprecision: mps_boolean,
    );
}
extern "C" {
    pub fn mps_context_set_crude_approximation_mode(
        s: *mut mps_context,
        crude_approximation_mode: mps_boolean,
    );
}
extern "C" {
    pub fn mps_context_set_regeneration_driver(
        s: *mut mps_context,
        rd: *mut mps_regeneration_driver,
    );
}
extern "C" {
    pub fn mps_context_set_debug_level(s: *mut mps_context, level: mps_debug_level);
}
extern "C" {
    pub fn mps_context_add_debug_domain(s: *mut mps_context, level: mps_debug_level);
}
extern "C" {
    pub fn mps_context_get_input_config(s: *mut mps_context) -> *mut mps_input_configuration;
}
extern "C" {
    pub fn mps_context_get_output_config(s: *mut mps_context) -> *mut mps_output_configuration;
}
extern "C" {
    pub fn mps_context_has_errors(s: *mut mps_context) -> mps_boolean;
}
extern "C" {
    pub fn mps_context_error_msg(s: *mut mps_context) -> *mut ::std::os::raw::c_char;
}
pub type gid_t = __gid_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn closefrom(__lowfd: ::std::os::raw::c_int);
}
extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
    ) -> isize;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> isize;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *mut ::std::os::raw::c_char,
        __envp: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int) -> !;
}
pub const _PC_LINK_MAX: _bindgen_ty_13 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_13 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_13 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_13 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_13 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_13 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_13 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_13 = 7;
pub const _PC_VDISABLE: _bindgen_ty_13 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_13 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_13 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_13 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_13 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_13 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_13 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_13 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_13 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_13 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_13 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_13 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_13 = 20;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const _SC_ARG_MAX: _bindgen_ty_14 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_14 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_14 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_14 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_14 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_14 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_14 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_14 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_14 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_14 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_14 = 10;
pub const _SC_TIMERS: _bindgen_ty_14 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_14 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_14 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_14 = 14;
pub const _SC_FSYNC: _bindgen_ty_14 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_14 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_14 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_14 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_14 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_14 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_14 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_14 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_14 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_14 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_14 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_14 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_14 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_14 = 28;
pub const _SC_VERSION: _bindgen_ty_14 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_14 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_14 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_14 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_14 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_14 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_14 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_14 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_14 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_14 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_14 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_14 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_14 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_14 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_14 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_14 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_14 = 45;
pub const _SC_2_VERSION: _bindgen_ty_14 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_14 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_14 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_14 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_14 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_14 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_14 = 52;
pub const _SC_PII: _bindgen_ty_14 = 53;
pub const _SC_PII_XTI: _bindgen_ty_14 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_14 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_14 = 56;
pub const _SC_PII_OSI: _bindgen_ty_14 = 57;
pub const _SC_POLL: _bindgen_ty_14 = 58;
pub const _SC_SELECT: _bindgen_ty_14 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_14 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_14 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_14 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_14 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_14 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_14 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_14 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_14 = 66;
pub const _SC_THREADS: _bindgen_ty_14 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_14 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_14 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_14 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_14 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_14 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_14 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_14 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_14 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_14 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_14 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_14 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_14 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_14 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_14 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_14 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_14 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_14 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_14 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_14 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_14 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_14 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_14 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_14 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_14 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_14 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_14 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_14 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_14 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_14 = 96;
pub const _SC_2_UPE: _bindgen_ty_14 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_14 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_14 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_14 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_14 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_14 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_14 = 103;
pub const _SC_INT_MAX: _bindgen_ty_14 = 104;
pub const _SC_INT_MIN: _bindgen_ty_14 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_14 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_14 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_14 = 108;
pub const _SC_NZERO: _bindgen_ty_14 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_14 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_14 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_14 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_14 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_14 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_14 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_14 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_14 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_14 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_14 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_14 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_14 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_14 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_14 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_14 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_14 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_14 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_14 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_14 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_14 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_14 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_14 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_14 = 132;
pub const _SC_BARRIERS: _bindgen_ty_14 = 133;
pub const _SC_BASE: _bindgen_ty_14 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_14 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_14 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_14 = 137;
pub const _SC_CPUTIME: _bindgen_ty_14 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_14 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_14 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_14 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_14 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_14 = 143;
pub const _SC_FIFO: _bindgen_ty_14 = 144;
pub const _SC_PIPE: _bindgen_ty_14 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_14 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_14 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_14 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_14 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_14 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_14 = 151;
pub const _SC_NETWORKING: _bindgen_ty_14 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_14 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_14 = 154;
pub const _SC_REGEXP: _bindgen_ty_14 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_14 = 156;
pub const _SC_SHELL: _bindgen_ty_14 = 157;
pub const _SC_SIGNALS: _bindgen_ty_14 = 158;
pub const _SC_SPAWN: _bindgen_ty_14 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_14 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_14 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_14 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_14 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_14 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_14 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_14 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_14 = 167;
pub const _SC_2_PBS: _bindgen_ty_14 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_14 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_14 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_14 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_14 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_14 = 173;
pub const _SC_STREAMS: _bindgen_ty_14 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_14 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_14 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_14 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_14 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_14 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_14 = 180;
pub const _SC_TRACE: _bindgen_ty_14 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_14 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_14 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_14 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_14 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_14 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_14 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_14 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_14 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_14 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_14 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_14 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_14 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_14 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_14 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_14 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_14 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_14 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_14 = 199;
pub const _SC_IPV6: _bindgen_ty_14 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_14 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_14 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_14 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_14 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_14 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_14 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_14 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_14 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_14 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_14 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_14 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_14 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_14 = 248;
pub const _SC_MINSIGSTKSZ: _bindgen_ty_14 = 249;
pub const _SC_SIGSTKSZ: _bindgen_ty_14 = 250;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
pub const _CS_PATH: _bindgen_ty_15 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_15 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_15 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_15 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_15 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_15 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_15 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_15 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_15 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_15 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_15 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_15 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_15 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_15 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_15 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_15 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_15 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_15 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_15 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_15 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_15 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_15 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_15 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_15 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_15 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_15 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_15 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_15 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_15 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_15 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_15 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_15 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_15 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_15 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_15 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_15 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_15 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_15 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_15 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_15 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_15 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_15 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_15 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_15 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_15 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_15 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_15 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_15 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_15 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_15 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_15 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_15 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_15 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_15 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_15 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_15 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_15 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_15 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_15 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_15 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_15 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_15 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_15 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_15 = 1149;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> usize;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *mut ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn crypt(
        __key: *const ::std::os::raw::c_char,
        __salt: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getentropy(
        __buffer: *mut ::std::os::raw::c_void,
        __length: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mps_start_timer() -> *mut clock_t;
}
extern "C" {
    pub fn mps_stop_timer(my_timer: *mut clock_t) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t
{
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t()
{
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t
{
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t()
{
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t
{
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t()
{
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval
{
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval()
{
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set
{
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set()
{
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data
{
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data()
{
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data
{
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data()
{
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn arc4random() -> __uint32_t;
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::std::os::raw::c_void, __size: usize);
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @mainpage General documentation\n\n @section About What is MPSolve\n MPSolve is a C library that allow to find solution to univariate polynomial equations\n with arbitrary precision.\n\n More precisely, MPSolve can handle polynomials but not necessarly in their monomial\n form. Support is now given even for secular equation and more implicit representation\n are scheduled to be added later.\n\n @section Installation Installing MPSolve system-wide\n First, you need to get MPSolve. You can get the latest release via <code>git</code>\n or download it via <code>http</code> grabbing it at http://www.dm.unipi.it/...\n If you downloaded the source tarball this operation is pretty straightforward.\n You can simply unpack it and then\n @code\n   ./configure\n   make\n   [sudo] make install\n @endcode\n\n These commands will install the library <code>libmps.so</code> in your system library\n directory. In this way you will be able compile your source file using a command similar\n to\n @code\n gcc -o myprogram -lmps -lgmp -lm myprogram.c.\n @endcode\n\n @section ExtendedTypes MPSolve extended arithmetic types\n To perform its computations MPSolve uses some more types than standard C does.\n You will need to interact with these to give and obtain data from MPSolve.\n\n There are three main category of types that you will be required to deal with:\n -# Standard floating point doubles;\n -# DPE types;\n -# Multiprecision GMP types\n\n @subsection FloatingPoint Floating point simple types\n There is clearly nothing to explain about floating point doubles, but MPSolve needs to deal\n with complex floating point and it uses a type called <code>cplx_t</code> that is nothing\n more than a struct with two double field, <code>r</code> and <code>i</code> that represents\n the real and imaginary part of the given complex number.\n You should access these fields with macro provided in this way:\n @code\n cplx_t my_complex_number;\n double theta = 0.5;\n cplx_Re (my_complex_number) = cos (theta);\n cplx_Im (my_complex_number) = sin (theta);\n @endcode\n\n Some standard complex number are provided for convenicence, such as <code>cplx_one</code>\n and <code>cplx_zero</code>.\n\n To get an idea of all the routines that you can use you can read the <code>mt.h</code> header\n file. But for a simple start, the routines that you will need are cplx_add(),\n cplx_sub(), cplx_mul() and cplx_div(). I think that it's pretty clear what they do.\n\n @subsection DPE The DPE types\n The <code>DPE</code> are have the same precision of the <code>double</code>s but allow\n the exponent to be much larger; the exponent is stored as a <code>long</code> value so\n the maximum reachable one is <code>LONG_MAX</code>, while the minimum is <code>LONG_MIN</code>.\n\n In the <code>mt</code> library that is embedded in MPSolve two version of the <code>DPE</code>\n types are provided: the real and the complex one. They are called <code>RDPE</code> and <code>CDPE</code>,\n respectively.\n\n The function used to handle these types are almost the same of the complex one case, so we will\n not cover they extensively here.\n\n @subsection GMP GMP types\n GMP types are used to represent multiprecision data that is used to get arbitrary high precision\n approximation of the roots. See http://gmplib.org for details on the use of GMP.\n\n @section Interface Using the libmps interface\n\n The library provides some useful routine to interact with the polynomial solver. Most of\n them are designed to handle polynomial definition and are implemented in <code>interface.c</code>\n\n This is a typical example of how you'll be using MPSolve.\n\n @code\n // Select the degree\n int n = 4;\n\n // Allocate a new mps_context that hold the status of a computation.\n // Its field should never be accessed directly but only via appropriate\n //functions.\n mps_context * status = mps_context_new ();\n\n // Create a polynomial that will be solved\n mps_monomial_poly * poly = mps_monomial_poly_new (status, n);\n\n // Set the coefficients. We will solve x^n - 1 in here\n mps_monomial_poly_set_coefficient_int (status, poly, 0, -1, 0);\n mps_monomial_poly_set_coefficient_int (status, poly, n,  1, 0);\n\n // Select some common output options, i.e. 512 bits of precision\n // (more or less 200 digits guaranteed) and approximation goal.\n mps_context_set_output_prec (status, 512);\n mps_context_set_output_goal (status, MPS_OUTPUT_GOAL_APPROXIMATE);\n\n // Solve the polynomial\n mps_context_set_input_poly (status, poly);\n mps_mpsolve (status);\n\n // Get the roots in a <code>cplx_t</code> vector. Please note that\n // this make completely useless to have asked 512 bits of output\n // precision, and you should use mps_context_get_roots_m() to get\n // multiprecision approximation of the roots.\n cplx_t * results = cplx_valloc (n);\n mps_context_get_roots_d (status, &results, NULL);\n\n // Free the data used. This will free the monomial_poly if you have\n // not done it by yourself.\n mps_context_free (status);\n cplx_vfree (results);\n @endcode\n\n As pointed out in the comments, this piece of code is not that smart, since it asks\n for a lot of digits in output, but then discard all this good by copying the roots\n in floating point <code>cplx_t</code> types.\n\n Please see the documentation of mps_context_get_roots_m() for a better way to get\n the results. It was not used in example in order to keep it short and clear.\n\n @subsection inclusion How to include libmps\n\n In general libmps will be usable by including the header file <code>mps/mps.h</code>.\n Please note that almost all structures defined in MPSolve will be available only as\n incomplete declarations, so they should be used with pointers, and manipulated with available\n functions.\n\n Remember to include always <code>mps/mps.h</code> and not the other headers in the\n directory. This is not supported and not guaranteed to work.\n\n For example you can instantiate a pointer to a new <code>mps_context</code> with\n the function <code>mps_context_new()</code>, add the input to it, solve the polynoial\n with <code>mps_mpsolve()</code> and then free its resources with <code>mps_context_free()</code>.\n\n The data structures that will be mostly used are:\n -# <code>mps_context</code>: This structure holds the state of the computation and must\n be instanciated for every polynomial solving operation. After allocating a pointer to\n an <code>mps_context</code> you should, generally,:\n   -# Set the input data and output requirements (i.e. the input polynomial, the desired\n   output digits and goal, ...)\n   -# Ask libmps to solve the polynomial by calling <code>mps_mpsolve()</code>\n   -# Retrieve the computed data with the appropriate accessors functions\n <code>mps_context_get_roots_d()</code> or <code>mps_context_get_roots_m()</code>.\n All the functions usable on an <code>mps_context</code> pointer are available in\n status.h.\n\n -# <code>mps_monomial_poly</code>: A polynomial given by its coefficients. Can be allocated\n with <code>mps_monomial_poly_new()</code> and manipulated with the functions in\n monomial-poly.h. Once it is the desired polynomial to solve you can call\n <code>mps_context_set_input_poly()</code> to set it as the active polynomial to solve.\n\n -# <code>mps_secular_equation</code>: The same as the monomial poly, but for secular equations.\n See secular-equation.h for some functions to allocate, free and manipulate them.\n\n @subsection async Calling MPSolve asynchronously\n\n Desktop application using MPSolve to solve polynomials may want to call a\n non-blocking version of mps_mpsolve(). This is provided inside the package\n as mps_mpsolve_async().\n\n This routine will return a <code>mps_handle</code> pointer that can be used to wait\n for the result by calling mps_mpsolve_wait() on it."]
    pub fn mps_set_default_values(s: *mut mps_context);
}
extern "C" {
    pub fn mps_mpsolve(s: *mut mps_context);
}
extern "C" {
    pub fn mps_standard_mpsolve(s: *mut mps_context);
}
extern "C" {
    pub fn mps_malloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mps_realloc(
        pointer: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn mps_mpsolve_async(
        s: *mut mps_context,
        callback: mps_callback,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn mps_parse_stream(s: *mut mps_context, input_stream: *mut FILE) -> *mut mps_polynomial;
}
extern "C" {
    pub fn mps_parse_file(
        s: *mut mps_context,
        path: *const ::std::os::raw::c_char,
    ) -> *mut mps_polynomial;
}
extern "C" {
    pub fn mps_parse_string(
        s: *mut mps_context,
        c_string: *const ::std::os::raw::c_char,
    ) -> *mut mps_polynomial;
}
extern "C" {
    pub fn mps_parse_inline_poly(ctx: *mut mps_context, stream: *mut FILE) -> *mut mps_polynomial;
}
extern "C" {
    pub fn mps_parse_inline_poly_from_string(
        ctx: *mut mps_context,
        input: *const ::std::os::raw::c_char,
    ) -> *mut mps_polynomial;
}
extern "C" {
    pub fn mps_get_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn mps_get_major_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mps_get_minor_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn mps_get_patch_version() -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data
{
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag
{
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag()
{
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
